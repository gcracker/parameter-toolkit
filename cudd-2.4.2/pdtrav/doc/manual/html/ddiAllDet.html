<html>
<head><title>The ddi package: all functions </title></head>
<body>

External functions and data strucures of the DDI package
<HR>
<DL>
<dt><pre>
<A NAME="ArrayOpIterate"></A>
static void <I></I>
<B>ArrayOpIterate</B>(
  Ddi_OpCode_e  <b>opcode</b>, <i>operation code</i>
  Ddi_ArrayData_t * <b>array</b>, <i>array</i>
  Ddi_Generic_t * <b>g</b>, <i>first operand</i>
  Ddi_Generic_t * <b>h</b> <i>first operand</i>
)
</pre>
<dd> Iterate operation on array entries (accumulate mode used)
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiGeneric.c"TARGET="ABSTRACT"><CODE>ddiGeneric.c</CODE></A>

<dt><pre>
<A NAME="ArrayResize"></A>
static void <I></I>
<B>ArrayResize</B>(
  Ddi_ArrayData_t * <b>array</b>, <i>array to be resized</i>
  int  <b>nSizeNew</b> <i>new size of array</i>
)
</pre>
<dd> Resize a DDI array using proper realloc function.
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiArray.c"TARGET="ABSTRACT"><CODE>ddiArray.c</CODE></A>

<dt><pre>
<A NAME="ArraySupp"></A>
static Ddi_Generic_t * <I></I>
<B>ArraySupp</B>(
  Ddi_ArrayData_t * <b>array</b> <i></i>
)
</pre>
<dd> Iterate operation on array entries (accumulate mode used)
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiGeneric.c"TARGET="ABSTRACT"><CODE>ddiGeneric.c</CODE></A>

<dt><pre>
<A NAME="DdiArrayAlloc"></A>
Ddi_ArrayData_t * <I></I>
<B>DdiArrayAlloc</B>(
  int  <b>length</b> <i>array length</i>
)
</pre>
<dd> Array allocation and initialization.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_Free">Ddi_Free</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiArray.c"TARGET="ABSTRACT"><CODE>ddiArray.c</CODE></A>

<dt><pre>
<A NAME="DdiArrayAppend"></A>
void <I></I>
<B>DdiArrayAppend</B>(
  Ddi_ArrayData_t * <b>array1</b>, <i>first array</i>
  Ddi_ArrayData_t * <b>array2</b> <i>array to be appended</i>
)
</pre>
<dd> Writes the elements of array2 after the last
               element of array1.
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiArray.c"TARGET="ABSTRACT"><CODE>ddiArray.c</CODE></A>

<dt><pre>
<A NAME="DdiArrayCopy"></A>
Ddi_ArrayData_t * <I></I>
<B>DdiArrayCopy</B>(
  Ddi_Mgr_t * <b>dd2</b>, <i>destination manager</i>
  Ddi_ArrayData_t * <b>old</b> <i>array to be duplicated</i>
)
</pre>
<dd> Copy a BDD array to a destination manager.
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiArray.c"TARGET="ABSTRACT"><CODE>ddiArray.c</CODE></A>

<dt><pre>
<A NAME="DdiArrayDup"></A>
Ddi_ArrayData_t * <I></I>
<B>DdiArrayDup</B>(
  Ddi_ArrayData_t * <b>old</b> <i>array to be duplicated</i>
)
</pre>
<dd> Duplicates an array. Duplication is recursively applied 
               to array entries. 
               The unused room of the first array is not copied.
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiArray.c"TARGET="ABSTRACT"><CODE>ddiArray.c</CODE></A>

<dt><pre>
<A NAME="DdiArrayExtract"></A>
Ddi_Generic_t * <I></I>
<B>DdiArrayExtract</B>(
  Ddi_ArrayData_t * <b>array</b>, <i>array</i>
  int  <b>i</b> <i>index</i>
)
</pre>
<dd> Return the pointer to the <em>i-th</em>
               element array. The object is removed from array and slots
               after i-th position shifted up.
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiArray.c"TARGET="ABSTRACT"><CODE>ddiArray.c</CODE></A>

<dt><pre>
<A NAME="DdiArrayFree"></A>
void <I></I>
<B>DdiArrayFree</B>(
  Ddi_ArrayData_t * <b>array</b> <i>array to be freed</i>
)
</pre>
<dd> Frees a DDI array. Array entries are recursively freed.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#DdiArrayAlloc">DdiArrayAlloc</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiArray.c"TARGET="ABSTRACT"><CODE>ddiArray.c</CODE></A>

<dt><pre>
<A NAME="DdiArrayInsert"></A>
void <I></I>
<B>DdiArrayInsert</B>(
  Ddi_ArrayData_t * <b>array</b>, <i>destination array</i>
  int  <b>i</b>, <i>position of new element</i>
  Ddi_Generic_t * <b>f</b>, <i>generic object to be inserted</i>
  Ddi_CopyType_e  <b>copy</b> <i>dup/mov selector</i>
)
</pre>
<dd> Insert <em>f</em> in <em>array</em> at <em>i</em>-th
               position. The inserted item is duplicated and the 
               <em>array</em> slots from <em>i</em> to the end are
               shifted to make room for the new element.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#DdiArrayWrite">DdiArrayWrite</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiArray.c"TARGET="ABSTRACT"><CODE>ddiArray.c</CODE></A>

<dt><pre>
<A NAME="DdiArrayNum"></A>
int <I></I>
<B>DdiArrayNum</B>(
  Ddi_ArrayData_t * <b>array</b> <i></i>
)
</pre>
<dd> Returns the number of elements of the array
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiArray.c"TARGET="ABSTRACT"><CODE>ddiArray.c</CODE></A>

<dt><pre>
<A NAME="DdiArrayRead"></A>
Ddi_Generic_t * <I></I>
<B>DdiArrayRead</B>(
  Ddi_ArrayData_t * <b>array</b>, <i>BDDs' array</i>
  int  <b>i</b> <i>index</i>
)
</pre>
<dd> Return the pointer to the <em>i-th</em>
               element array. The object is NOT duplicated (this should 
               be done externally if required).
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiArray.c"TARGET="ABSTRACT"><CODE>ddiArray.c</CODE></A>

<dt><pre>
<A NAME="DdiArrayStore"></A>
int <I></I>
<B>DdiArrayStore</B>(
  Ddi_ArrayData_t * <b>array</b>, <i>array to be stored</i>
  char * <b>ddname</b>, <i>dd name (or NULL)</i>
  char ** <b>vnames</b>, <i>array of variable names (or NULL)</i>
  char ** <b>rnames</b>, <i>array of root names (or NULL)</i>
  int * <b>vauxids</b>, <i>array of aux var ids (or NULL)</i>
  int  <b>mode</b>, <i>storing mode selector</i>
  char * <b>fname</b>, <i>file name</i>
  FILE * <b>fp</b> <i>pointer to the store file</i>
)
</pre>
<dd> This function stores a BDD array using the
               DDDMP format. The parameter "mode" 
               can be DDDMP_MODE_TEXT, DDDMP_MODE_COMPRESSED or
               DDDMP_MODE_AUTOMATIC.<br>
               The function returns 1 if succefully stored, 0 otherwise.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Dddmp_cuddBddStore">Dddmp_cuddBddStore</a>
<a href="#Ddi_BddStore">Ddi_BddStore</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiArray.c"TARGET="ABSTRACT"><CODE>ddiArray.c</CODE></A>

<dt><pre>
<A NAME="DdiArrayToCU"></A>
DdNode ** <I></I>
<B>DdiArrayToCU</B>(
  Ddi_ArrayData_t * <b>array</b> <i></i>
)
</pre>
<dd> Generate a dynamically allocated array of pointers to CUDD 
    BDDs, one for each entry in the DDI array. Array entries are required
    to be monolithic.
    The number of array entries is equal to DdiArrayNum(array), but the 
    array is overdimensioned (by one NULL slot) to make it NULL-terminated.
    The array of pointers is allocated (so explicit free is required), whereas
    the CUDD nodes are NOT referenced.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_BddarrayMakeFromCU">Ddi_BddarrayMakeFromCU</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiArray.c"TARGET="ABSTRACT"><CODE>ddiArray.c</CODE></A>

<dt><pre>
<A NAME="DdiArrayWrite"></A>
void <I></I>
<B>DdiArrayWrite</B>(
  Ddi_ArrayData_t * <b>array</b>, <i>destination array</i>
  int  <b>i</b>, <i>position of new element</i>
  Ddi_Generic_t * <b>f</b>, <i>generic object to be written</i>
  Ddi_CopyType_e  <b>copy</b> <i>dup/mov selector</i>
)
</pre>
<dd> Write <em>f</em> in <em>array</em> at <em>i</em>-th
               position. The inserted item is duplicated.
               No shift is done. The previous content of array
               is freed (if not NULL) and overwritten.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#DdiArrayInsert">DdiArrayInsert</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiArray.c"TARGET="ABSTRACT"><CODE>ddiArray.c</CODE></A>

<dt><pre>
<A NAME="DdiDeferredFree"></A>
Ddi_Generic_t * <I></I>
<B>DdiDeferredFree</B>(
  Ddi_Generic_t * <b>f</b> <i>block to be freed</i>
)
</pre>
<dd> Schedule free a generic block.
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiGeneric.c"TARGET="ABSTRACT"><CODE>ddiGeneric.c</CODE></A>

<dt><pre>
<A NAME="DdiGenericAlloc"></A>
Ddi_Generic_t * <I></I>
<B>DdiGenericAlloc</B>(
  Ddi_Type_e  <b>type</b>, <i>type of allocated object</i>
  Ddi_Mgr_t * <b>mgr</b> <i>DDI manager</i>
)
</pre>
<dd> Allocation and initialization of generic DDI block.
               owner DDI manager always required.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#DdiGenericNew">DdiGenericNew</a>
<a href="#DdiGenericFree">DdiGenericFree</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiGeneric.c"TARGET="ABSTRACT"><CODE>ddiGeneric.c</CODE></A>

<dt><pre>
<A NAME="DdiGenericBddSize"></A>
int <I></I>
<B>DdiGenericBddSize</B>(
  Ddi_Generic_t * <b>f</b> <i>BDD to be duplicated</i>
)
</pre>
<dd> Compute BDD size. Sharing size is used, so shared nodes are 
    counted only once.
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiGeneric.c"TARGET="ABSTRACT"><CODE>ddiGeneric.c</CODE></A>

<dt><pre>
<A NAME="DdiGenericCopy"></A>
Ddi_Generic_t * <I></I>
<B>DdiGenericCopy</B>(
  Ddi_Mgr_t * <b>ddm</b>, <i>destination manager</i>
  Ddi_Generic_t * <b>f</b>, <i>BDD to be duplicated</i>
  Ddi_Vararray_t * <b>varsOld</b>, <i>old variable array</i>
  Ddi_Vararray_t * <b>varsNew</b> <i>new variable array</i>
)
</pre>
<dd> Copy a DDI node to a destination manager
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiGeneric.c"TARGET="ABSTRACT"><CODE>ddiGeneric.c</CODE></A>

<dt><pre>
<A NAME="DdiGenericDataCopy"></A>
void <I></I>
<B>DdiGenericDataCopy</B>(
  Ddi_Generic_t * <b>d</b>, <i>destination</i>
  Ddi_Generic_t * <b>s</b> <i>source</i>
)
</pre>
<dd> Copy the content of a DDI node to another one.
    Freing is done before copy. Data are duplicated
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiGeneric.c"TARGET="ABSTRACT"><CODE>ddiGeneric.c</CODE></A>

<dt><pre>
<A NAME="DdiGenericDup"></A>
Ddi_Generic_t * <I></I>
<B>DdiGenericDup</B>(
  Ddi_Generic_t * <b>f</b> <i>BDD to be duplicated</i>
)
</pre>
<dd> Duplicate a DDI node
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiGeneric.c"TARGET="ABSTRACT"><CODE>ddiGeneric.c</CODE></A>

<dt><pre>
<A NAME="DdiGenericFree"></A>
void <I></I>
<B>DdiGenericFree</B>(
  Ddi_Generic_t * <b>f</b> <i>block to be freed</i>
)
</pre>
<dd> Frees a generic block.
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiGeneric.c"TARGET="ABSTRACT"><CODE>ddiGeneric.c</CODE></A>

<dt><pre>
<A NAME="DdiGenericOp"></A>
Ddi_Generic_t * <I></I>
<B>DdiGenericOp</B>(
  Ddi_OpCode_e  <b>opcode</b>, <i>operation code</i>
  Ddi_OpType_e  <b>optype</b>, <i>operation type (accumulate/generate)</i>
  Ddi_Generic_t * <b>f</b>, <i>first operand</i>
  Ddi_Generic_t * <b>g</b>, <i>first operand</i>
  Ddi_Generic_t * <b>h</b> <i>first operand</i>
)
</pre>
<dd> Compute operation
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiGeneric.c"TARGET="ABSTRACT"><CODE>ddiGeneric.c</CODE></A>

<dt><pre>
<A NAME="DdiMetaAndAcc"></A>
Ddi_Bdd_t * <I></I>
<B>DdiMetaAndAcc</B>(
  Ddi_Bdd_t * <b>fMeta</b>, <i></i>
  Ddi_Bdd_t * <b>gMeta</b> <i></i>
)
</pre>
<dd> Operate And between two Meta BDDs
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiMeta.c"TARGET="ABSTRACT"><CODE>ddiMeta.c</CODE></A>

<dt><pre>
<A NAME="DdiMetaAndExistAcc"></A>
Ddi_Bdd_t * <I></I>
<B>DdiMetaAndExistAcc</B>(
  Ddi_Bdd_t * <b>fMeta</b>, <i></i>
  Ddi_Bdd_t * <b>gBdd</b>, <i></i>
  Ddi_Varset_t * <b>smooth</b> <i></i>
)
</pre>
<dd> Operate And-Exist between Meta BDD and monolithic BDD
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiMeta.c"TARGET="ABSTRACT"><CODE>ddiMeta.c</CODE></A>

<dt><pre>
<A NAME="DdiMetaComposeAcc"></A>
Ddi_Bdd_t * <I></I>
<B>DdiMetaComposeAcc</B>(
  Ddi_Bdd_t * <b>fMeta</b>, <i></i>
  Ddi_Vararray_t * <b>v</b>, <i></i>
  Ddi_Bddarray_t * <b>g</b> <i></i>
)
</pre>
<dd> Operate compose
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiMeta.c"TARGET="ABSTRACT"><CODE>ddiMeta.c</CODE></A>

<dt><pre>
<A NAME="DdiMetaDoCompl"></A>
void <I></I>
<B>DdiMetaDoCompl</B>(
  Ddi_Meta_t * <b>m</b> <i></i>
)
</pre>
<dd> Complement (not) meta BDD. Result accumulated. Operation is
    achieved by swapping the one/zero arrays
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiMeta.c"TARGET="ABSTRACT"><CODE>ddiMeta.c</CODE></A>

<dt><pre>
<A NAME="DdiMetaDup"></A>
Ddi_Meta_t * <I></I>
<B>DdiMetaDup</B>(
  Ddi_Meta_t * <b>m</b> <i></i>
)
</pre>
<dd> Duplicate meta struct
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiMeta.c"TARGET="ABSTRACT"><CODE>ddiMeta.c</CODE></A>

<dt><pre>
<A NAME="DdiMetaFree"></A>
void <I></I>
<B>DdiMetaFree</B>(
  Ddi_Meta_t * <b>m</b> <i></i>
)
</pre>
<dd> Free meta struct and pointed arrays: one, zero and dc.
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiMeta.c"TARGET="ABSTRACT"><CODE>ddiMeta.c</CODE></A>

<dt><pre>
<A NAME="DdiMetaIsConst"></A>
int <I></I>
<B>DdiMetaIsConst</B>(
  Ddi_Bdd_t * <b>fMeta</b>, <i></i>
  int  <b>phase</b> <i></i>
)
</pre>
<dd> Return true if meta BDD is constant. Phase = 1 for one, 0 for
    zero constant.
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiMeta.c"TARGET="ABSTRACT"><CODE>ddiMeta.c</CODE></A>

<dt><pre>
<A NAME="DdiMetaOrAcc"></A>
Ddi_Bdd_t * <I></I>
<B>DdiMetaOrAcc</B>(
  Ddi_Bdd_t * <b>fMeta</b>, <i></i>
  Ddi_Bdd_t * <b>gMeta</b> <i></i>
)
</pre>
<dd> Operate Or between two Meta BDDs
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiMeta.c"TARGET="ABSTRACT"><CODE>ddiMeta.c</CODE></A>

<dt><pre>
<A NAME="DdiMetaSubstVarsAcc"></A>
Ddi_Bdd_t * <I></I>
<B>DdiMetaSubstVarsAcc</B>(
  Ddi_Bdd_t * <b>fMeta</b>, <i></i>
  Ddi_Vararray_t * <b>v1</b>, <i></i>
  Ddi_Vararray_t * <b>v2</b> <i></i>
)
</pre>
<dd> Operate variable substitution
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiMeta.c"TARGET="ABSTRACT"><CODE>ddiMeta.c</CODE></A>

<dt><pre>
<A NAME="DdiMetaSupp"></A>
Ddi_Varset_t * <I></I>
<B>DdiMetaSupp</B>(
  Ddi_Meta_t * <b>m</b> <i></i>
)
</pre>
<dd> Return support of Meta BDD
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiMeta.c"TARGET="ABSTRACT"><CODE>ddiMeta.c</CODE></A>

<dt><pre>
<A NAME="DdiMetaSwapVarsAcc"></A>
Ddi_Bdd_t * <I></I>
<B>DdiMetaSwapVarsAcc</B>(
  Ddi_Bdd_t * <b>fMeta</b>, <i></i>
  Ddi_Vararray_t * <b>v1</b>, <i></i>
  Ddi_Vararray_t * <b>v2</b> <i></i>
)
</pre>
<dd> Operate variable swap
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiMeta.c"TARGET="ABSTRACT"><CODE>ddiMeta.c</CODE></A>

<dt><pre>
<A NAME="DdiMgrCheckVararraySize"></A>
void <I></I>
<B>DdiMgrCheckVararraySize</B>(
  Ddi_Mgr_t * <b>dd</b> <i>source dd manager</i>
)
</pre>
<dd> make checks and resizes arrays if required
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiMgr.c"TARGET="ABSTRACT"><CODE>ddiMgr.c</CODE></A>

<dt><pre>
<A NAME="DdiMgrGarbageCollect"></A>
void <I></I>
<B>DdiMgrGarbageCollect</B>(
  Ddi_Mgr_t * <b>ddm</b> <i></i>
)
</pre>
<dd> Garbage collect freed nodes (handles) in manager node list
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiMgr.c"TARGET="ABSTRACT"><CODE>ddiMgr.c</CODE></A>

<dt><pre>
<A NAME="DdiMgrMakeVarGroup"></A>
void <I></I>
<B>DdiMgrMakeVarGroup</B>(
  Ddi_BddMgr * <b>dd</b>, <i></i>
  Ddi_Var_t * <b>v</b>, <i></i>
  int  <b>grpSize</b>, <i></i>
  int  <b>method</b> <i></i>
)
</pre>
<dd> Create a variable group. Method is one of MTR_FIXED, 
    MTR_DEFAULT
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiMgr.c"TARGET="ABSTRACT"><CODE>ddiMgr.c</CODE></A>

<dt><pre>
<A NAME="DdiMgrReadIntRef"></A>
int <I></I>
<B>DdiMgrReadIntRef</B>(
  Ddi_Mgr_t * <b>dd</b> <i>source dd manager</i>
)
</pre>
<dd> Read the number of internally referenced DDI handles.
    Variable array and/or one/zero constants.
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiMgr.c"TARGET="ABSTRACT"><CODE>ddiMgr.c</CODE></A>

<dt><pre>
<A NAME="DdiTraceNodeAlloc"></A>
void <I></I>
<B>DdiTraceNodeAlloc</B>(
  Ddi_Generic_t * <b>r</b> <i></i>
)
</pre>
<dd> Trace allocation of DDI node. Put a debugger breakpoint on this
               routine to watch allocation of a node, given its ID. The id is
               retrieved from a previous run (e.g. logged as non freed DDI 
               node in MgrCheck by Ddi_MgrPrintExtRef.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_MgrSetTracedId">Ddi_MgrSetTracedId</a>
<a href="#Ddi_MgrPrintExtRef">Ddi_MgrPrintExtRef</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiGeneric.c"TARGET="ABSTRACT"><CODE>ddiGeneric.c</CODE></A>

<dt><pre>
<A NAME="DdiVarNewFromCU"></A>
void <I></I>
<B>DdiVarNewFromCU</B>(
  Ddi_BddMgr * <b>ddm</b>, <i></i>
  DdNode * <b>varCU</b> <i></i>
)
</pre>
<dd> Create a variable
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiVar.c"TARGET="ABSTRACT"><CODE>ddiVar.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddAndAcc"></A>
Ddi_Bdd_t * <I></I>
<B>Ddi_BddAndAcc</B>(
  Ddi_Bdd_t * <b>f</b>, <i></i>
  Ddi_Bdd_t * <b>g</b> <i></i>
)
</pre>
<dd> Compute f & g. Previous content of f is freed and new result
               is copyed to f. Since f points to a handle, it can be passed
               by value: the handle is kept when freeing old content.
               Accumulate type operations are useful to avoid temporary
               variables and explicit free of old data.
               The pointer to f (old handle) is returned so that the function
               may be used as operand for other functions.
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiBdd.c"TARGET="ABSTRACT"><CODE>ddiBdd.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddAndExistAcc"></A>
Ddi_Bdd_t * <I></I>
<B>Ddi_BddAndExistAcc</B>(
  Ddi_Bdd_t * <b>f</b>, <i></i>
  Ddi_Bdd_t * <b>g</b>, <i></i>
  Ddi_Varset_t * <b>vars</b> <i></i>
)
</pre>
<dd> Relational product (Exist(f&g,vars)). New result is accumulated
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_BddAnd">Ddi_BddAnd</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiBdd.c"TARGET="ABSTRACT"><CODE>ddiBdd.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddAndExist"></A>
Ddi_Bdd_t * <I></I>
<B>Ddi_BddAndExist</B>(
  Ddi_Bdd_t * <b>f</b>, <i></i>
  Ddi_Bdd_t * <b>g</b>, <i></i>
  Ddi_Varset_t * <b>vars</b> <i></i>
)
</pre>
<dd> Relational product (Exist(f&g,vars)). New result is generated
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_BddAnd">Ddi_BddAnd</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiBdd.c"TARGET="ABSTRACT"><CODE>ddiBdd.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddAnd"></A>
Ddi_Bdd_t * <I></I>
<B>Ddi_BddAnd</B>(
  Ddi_Bdd_t * <b>f</b>, <i></i>
  Ddi_Bdd_t * <b>g</b> <i></i>
)
</pre>
<dd> Compute f & g. A new result is generated and returned. 
               Input parameters are NOT changed
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_BddNot">Ddi_BddNot</a>
<a href="#Ddi_BddOr">Ddi_BddOr</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiBdd.c"TARGET="ABSTRACT"><CODE>ddiBdd.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddArraySetMeta"></A>
Ddi_Bddarray_t * <I></I>
<B>Ddi_BddArraySetMeta</B>(
  Ddi_Bddarray_t * <b>f</b> <i></i>
)
</pre>
<dd> Transform a BDD array to Meta BDD. Result accumulated
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiMeta.c"TARGET="ABSTRACT"><CODE>ddiMeta.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddCofactorAcc"></A>
Ddi_Bdd_t * <I></I>
<B>Ddi_BddCofactorAcc</B>(
  Ddi_Bdd_t * <b>f</b>, <i></i>
  Ddi_Var_t * <b>v</b>, <i></i>
  int  <b>phase</b> <i></i>
)
</pre>
<dd> Cofactor with variable. New result is accumulated
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiBdd.c"TARGET="ABSTRACT"><CODE>ddiBdd.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddCofactor"></A>
Ddi_Bdd_t * <I></I>
<B>Ddi_BddCofactor</B>(
  Ddi_Bdd_t * <b>f</b>, <i></i>
  Ddi_Var_t * <b>v</b>, <i></i>
  int  <b>phase</b> <i></i>
)
</pre>
<dd> Cofactor with variable. New result is generated
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiBdd.c"TARGET="ABSTRACT"><CODE>ddiBdd.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddCofexist"></A>
Ddi_Bdd_t * <I></I>
<B>Ddi_BddCofexist</B>(
  Ddi_Bdd_t * <b>f</b>, <i></i>
  Ddi_Bdd_t * <b>g</b>, <i></i>
  Ddi_Varset_t * <b>smooth</b> <i></i>
)
</pre>
<dd> Constrain cofactor. New result is generated
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_BddAnd">Ddi_BddAnd</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiBdd.c"TARGET="ABSTRACT"><CODE>ddiBdd.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddComposeAcc"></A>
Ddi_Bdd_t * <I></I>
<B>Ddi_BddComposeAcc</B>(
  Ddi_Bdd_t * <b>f</b>, <i></i>
  Ddi_Vararray_t * <b>x</b>, <i>array of variables</i>
  Ddi_Bddarray_t * <b>g</b> <i>array of functions</i>
)
</pre>
<dd> Function composition x <- g in f. New result is accumulated.  
               Vector composition algorithm is used.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_BddSwapVars">Ddi_BddSwapVars</a>
<a href="#Ddi_BddSubstVars">Ddi_BddSubstVars</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiBdd.c"TARGET="ABSTRACT"><CODE>ddiBdd.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddCompose"></A>
Ddi_Bdd_t * <I></I>
<B>Ddi_BddCompose</B>(
  Ddi_Bdd_t * <b>f</b>, <i></i>
  Ddi_Vararray_t * <b>x</b>, <i>array of variables</i>
  Ddi_Bddarray_t * <b>g</b> <i>array of functions</i>
)
</pre>
<dd> Function composition x <- g in f. New result is generated.  
               Vector composition algorithm is used.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_BddSwapVars">Ddi_BddSwapVars</a>
<a href="#Ddi_BddSubstVars">Ddi_BddSubstVars</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiBdd.c"TARGET="ABSTRACT"><CODE>ddiBdd.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddConstrainAcc"></A>
Ddi_Bdd_t * <I></I>
<B>Ddi_BddConstrainAcc</B>(
  Ddi_Bdd_t * <b>f</b>, <i></i>
  Ddi_Bdd_t * <b>g</b> <i></i>
)
</pre>
<dd> Constrain cofactor. New result is accumulated
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_BddAndAcc">Ddi_BddAndAcc</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiBdd.c"TARGET="ABSTRACT"><CODE>ddiBdd.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddConstrain"></A>
Ddi_Bdd_t * <I></I>
<B>Ddi_BddConstrain</B>(
  Ddi_Bdd_t * <b>f</b>, <i></i>
  Ddi_Bdd_t * <b>g</b> <i></i>
)
</pre>
<dd> Constrain cofactor. New result is generated
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_BddAnd">Ddi_BddAnd</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiBdd.c"TARGET="ABSTRACT"><CODE>ddiBdd.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddCopyRemapVars"></A>
Ddi_Bdd_t * <I></I>
<B>Ddi_BddCopyRemapVars</B>(
  Ddi_Mgr_t * <b>ddm</b>, <i>destination manager</i>
  Ddi_Bdd_t * <b>old</b>, <i>BDD to be duplicated</i>
  Ddi_Vararray_t * <b>varsOld</b>, <i>old variable array</i>
  Ddi_Vararray_t * <b>varsNew</b> <i>new variable array</i>
)
</pre>
<dd> Copy a Ddi_Bdd_t to a destination DDI manager.
    Variable correspondence is established "by index", i.e. 
    variables with same index in different manager correspond. 
    Bdd is simply duplicated if destination manager is equal to the 
    source one.
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiBdd.c"TARGET="ABSTRACT"><CODE>ddiBdd.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddCopy"></A>
Ddi_Bdd_t * <I></I>
<B>Ddi_BddCopy</B>(
  Ddi_Mgr_t * <b>ddm</b>, <i>destination manager</i>
  Ddi_Bdd_t * <b>old</b> <i>BDD to be duplicated</i>
)
</pre>
<dd> Copy a Ddi_Bdd_t to a destination DDI manager.
    Variable correspondence is established "by index", i.e. 
    variables with same index in different manager correspond. 
    Bdd is simply duplicated if destination manager is equal to the 
    source one.
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiBdd.c"TARGET="ABSTRACT"><CODE>ddiBdd.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddCprojectAcc"></A>
Ddi_Bdd_t * <I></I>
<B>Ddi_BddCprojectAcc</B>(
  Ddi_Bdd_t * <b>f</b>, <i></i>
  Ddi_Bdd_t * <b>g</b> <i></i>
)
</pre>
<dd> Compatible projector. New result is accumulated
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_BddAndAcc">Ddi_BddAndAcc</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiBdd.c"TARGET="ABSTRACT"><CODE>ddiBdd.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddCproject"></A>
Ddi_Bdd_t * <I></I>
<B>Ddi_BddCproject</B>(
  Ddi_Bdd_t * <b>f</b>, <i></i>
  Ddi_Bdd_t * <b>g</b> <i></i>
)
</pre>
<dd> Compatible projector. New result is generated
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_BddAnd">Ddi_BddAnd</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiBdd.c"TARGET="ABSTRACT"><CODE>ddiBdd.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddDenseSet"></A>
Ddi_Bdd_t * <I></I>
<B>Ddi_BddDenseSet</B>(
  Ddi_DenseMethod_e  <b>method</b>, <i>Operation Code</i>
  Ddi_Bdd_t * <b>f</b>, <i>Operand</i>
  int  <b>threshold</b>, <i></i>
  int  <b>safe</b>, <i></i>
  int  <b>quality</b>, <i></i>
  double  <b>hardlimit</b> <i></i>
)
</pre>
<dd> Compute the Dense Super or Subset of a Boolean functions
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiBdd.c"TARGET="ABSTRACT"><CODE>ddiBdd.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddDiffAcc"></A>
Ddi_Bdd_t * <I></I>
<B>Ddi_BddDiffAcc</B>(
  Ddi_Bdd_t * <b>f</b>, <i></i>
  Ddi_Bdd_t * <b>g</b> <i></i>
)
</pre>
<dd> Boolean difference (f & !g). Result is accumulated
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_BddAndAcc">Ddi_BddAndAcc</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiBdd.c"TARGET="ABSTRACT"><CODE>ddiBdd.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddDiff"></A>
Ddi_Bdd_t * <I></I>
<B>Ddi_BddDiff</B>(
  Ddi_Bdd_t * <b>f</b>, <i></i>
  Ddi_Bdd_t * <b>g</b> <i></i>
)
</pre>
<dd> Boolean difference (f & !g). New result is generated
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_BddAnd">Ddi_BddAnd</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiBdd.c"TARGET="ABSTRACT"><CODE>ddiBdd.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddDup"></A>
Ddi_Bdd_t * <I></I>
<B>Ddi_BddDup</B>(
  Ddi_Bdd_t * <b>f</b> <i>BDD to be duplicated</i>
)
</pre>
<dd> Duplicate a Ddi_Bdd_t. All pointed objects are recursively 
    duplicated. In case of partitioned
    BDDs, array of partitions are duplicated. Cudd BDDs are referenced.
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiBdd.c"TARGET="ABSTRACT"><CODE>ddiBdd.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddEqual"></A>
int <I></I>
<B>Ddi_BddEqual</B>(
  Ddi_Bdd_t * <b>f</b>, <i>first dd</i>
  Ddi_Bdd_t * <b>g</b> <i>second dd</i>
)
</pre>
<dd> Return true (non 0) if the two DDs are equal (f==g).
    This test is presently limited to monolithic BDDs.
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiBdd.c"TARGET="ABSTRACT"><CODE>ddiBdd.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddEvalFree"></A>
Ddi_Bdd_t * <I></I>
<B>Ddi_BddEvalFree</B>(
  Ddi_Bdd_t * <b>f</b>, <i>expression</i>
  Ddi_Bdd_t * <b>g</b> <i>BDD to be freed</i>
)
</pre>
<dd> Useful for accumulator like expressions (g=f(g,h)), i.e.
    computing a new value for a variable
    and the old value must be freed. Avoids using temporary
    variables. Since the f expression is evalued before
    passing actual parameters, freeing of g occurs as last
    operation. 
    <pre>
    E.g. 
          g=Ddi_BddEvalFree(Ddi_BddAnd(g,h),g).
    </pre>
    The "accumulator" style operations introduced from version 2.0 of
    pdtrav should stongly reduce the need for this technique. The above 
    example can now be written as:
    <pre>
          Ddi_BddAndAcc(g,h).
    </pre>
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_BddAndAcc">Ddi_BddAndAcc</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiBdd.c"TARGET="ABSTRACT"><CODE>ddiBdd.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddExistAcc"></A>
Ddi_Bdd_t * <I></I>
<B>Ddi_BddExistAcc</B>(
  Ddi_Bdd_t * <b>f</b>, <i></i>
  Ddi_Varset_t * <b>vars</b> <i></i>
)
</pre>
<dd> Existential abstraction. New result is accumulated
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_BddAnd">Ddi_BddAnd</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiBdd.c"TARGET="ABSTRACT"><CODE>ddiBdd.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddExist"></A>
Ddi_Bdd_t * <I></I>
<B>Ddi_BddExist</B>(
  Ddi_Bdd_t * <b>f</b>, <i></i>
  Ddi_Varset_t * <b>vars</b> <i></i>
)
</pre>
<dd> Existential abstraction. New result is generated
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_BddAnd">Ddi_BddAnd</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiBdd.c"TARGET="ABSTRACT"><CODE>ddiBdd.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddForallAcc"></A>
Ddi_Bdd_t * <I></I>
<B>Ddi_BddForallAcc</B>(
  Ddi_Bdd_t * <b>f</b>, <i></i>
  Ddi_Varset_t * <b>vars</b> <i></i>
)
</pre>
<dd> Universal abstraction. New result is accumulated
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_BddAnd">Ddi_BddAnd</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiBdd.c"TARGET="ABSTRACT"><CODE>ddiBdd.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddForall"></A>
Ddi_Bdd_t * <I></I>
<B>Ddi_BddForall</B>(
  Ddi_Bdd_t * <b>f</b>, <i></i>
  Ddi_Varset_t * <b>vars</b> <i></i>
)
</pre>
<dd> Universal abstraction. New result is generated
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_BddAnd">Ddi_BddAnd</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiBdd.c"TARGET="ABSTRACT"><CODE>ddiBdd.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddFromMeta"></A>
Ddi_Bdd_t * <I></I>
<B>Ddi_BddFromMeta</B>(
  Ddi_Bdd_t * <b>f</b> <i></i>
)
</pre>
<dd> Transform a BDD to Meta BDD. Result accumulated
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiMeta.c"TARGET="ABSTRACT"><CODE>ddiMeta.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddIncluded"></A>
int <I></I>
<B>Ddi_BddIncluded</B>(
  Ddi_Bdd_t * <b>f</b>, <i></i>
  Ddi_Bdd_t * <b>g</b> <i></i>
)
</pre>
<dd> Check for inclusion (f in g). Return non 0 if true.
    This test requires the second operand (g) to be monolithic, whereas
    monolithic and disjunctively partitioned forms are allowed for first
    operand (f).
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiBdd.c"TARGET="ABSTRACT"><CODE>ddiBdd.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddIsCube"></A>
int <I></I>
<B>Ddi_BddIsCube</B>(
  Ddi_Bdd_t * <b>f</b> <i></i>
)
</pre>
<dd> Return true (non 0) if f is a cube. Monolithic BDD required.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_BddIsOne">Ddi_BddIsOne</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiBdd.c"TARGET="ABSTRACT"><CODE>ddiBdd.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddIsMeta"></A>
int <I></I>
<B>Ddi_BddIsMeta</B>(
  Ddi_Bdd_t * <b>f</b> <i></i>
)
</pre>
<dd> Return true (non 0) if f is a meta BDD.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_BddIsPartConj">Ddi_BddIsPartConj</a>
<a href="#Ddi_BddIsPartDisj">Ddi_BddIsPartDisj</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiBdd.c"TARGET="ABSTRACT"><CODE>ddiBdd.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddIsMono"></A>
int <I></I>
<B>Ddi_BddIsMono</B>(
  Ddi_Bdd_t * <b>f</b> <i></i>
)
</pre>
<dd> Return true (non 0) if f is a monolithic BDD.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_BddIsPartConj">Ddi_BddIsPartConj</a>
<a href="#Ddi_BddIsPartDisj">Ddi_BddIsPartDisj</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiBdd.c"TARGET="ABSTRACT"><CODE>ddiBdd.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddIsOne"></A>
int <I></I>
<B>Ddi_BddIsOne</B>(
  Ddi_Bdd_t * <b>f</b> <i></i>
)
</pre>
<dd> Return true (non 0) if f is the one constant.
    This test is presently limited to monolithic BDDs.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_BddIsZero">Ddi_BddIsZero</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiBdd.c"TARGET="ABSTRACT"><CODE>ddiBdd.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddIsPartConj"></A>
int <I></I>
<B>Ddi_BddIsPartConj</B>(
  Ddi_Bdd_t * <b>f</b> <i></i>
)
</pre>
<dd> Return true (non 0) if f is a conjunctively partitioned BDD.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_BddIsMono">Ddi_BddIsMono</a>
<a href="#Ddi_BddIsPartDisj">Ddi_BddIsPartDisj</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiBdd.c"TARGET="ABSTRACT"><CODE>ddiBdd.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddIsPartDisj"></A>
int <I></I>
<B>Ddi_BddIsPartDisj</B>(
  Ddi_Bdd_t * <b>f</b> <i></i>
)
</pre>
<dd> Return true (non 0) if f is a disjunctively partitioned BDD.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_BddIsMono">Ddi_BddIsMono</a>
<a href="#Ddi_BddIsPartConj">Ddi_BddIsPartConj</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiBdd.c"TARGET="ABSTRACT"><CODE>ddiBdd.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddIsZero"></A>
int <I></I>
<B>Ddi_BddIsZero</B>(
  Ddi_Bdd_t * <b>f</b> <i></i>
)
</pre>
<dd> Return true (non 0) if f is the zero constant.
    This test is presently limited to monolithic BDDs.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_BddIsOne">Ddi_BddIsOne</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiBdd.c"TARGET="ABSTRACT"><CODE>ddiBdd.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddIteAcc"></A>
Ddi_Bdd_t * <I></I>
<B>Ddi_BddIteAcc</B>(
  Ddi_Bdd_t * <b>f</b>, <i></i>
  Ddi_Bdd_t * <b>g</b>, <i></i>
  Ddi_Bdd_t * <b>h</b> <i></i>
)
</pre>
<dd> If-Then-Else (ITE(f,g,h)). New result is accumulated
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_BddAndAcc">Ddi_BddAndAcc</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiBdd.c"TARGET="ABSTRACT"><CODE>ddiBdd.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddIte"></A>
Ddi_Bdd_t * <I></I>
<B>Ddi_BddIte</B>(
  Ddi_Bdd_t * <b>f</b>, <i></i>
  Ddi_Bdd_t * <b>g</b>, <i></i>
  Ddi_Bdd_t * <b>h</b> <i></i>
)
</pre>
<dd> If-Then-Else (ITE(f,g,h)). New result is generated
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_BddAnd">Ddi_BddAnd</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiBdd.c"TARGET="ABSTRACT"><CODE>ddiBdd.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddLoad"></A>
Ddi_Bdd_t * <I></I>
<B>Ddi_BddLoad</B>(
  Ddi_BddMgr * <b>dd</b>, <i>dd manager</i>
  int  <b>varmatchmode</b>, <i>variable matching mode</i>
  char  <b>mode</b>, <i>loading mode</i>
  char * <b>filename</b>, <i>file name</i>
  FILE * <b>fp</b> <i>file pointer</i>
)
</pre>
<dd> This function loads only a BDD. If the file contain a BDDs'
    array, then will be load only the first BDD.<br>
    The BDD on file must be in the DDDMP format. The parameter 
    "mode" can be DDDMP_MODE_TEXT, DDDMP_MODE_BINARY or
    DDDMP_MODE_DEFAULT.<br>
    The function returns the pointer of BDD root if succefully
    loaded, NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_BddStore">Ddi_BddStore</a>
<a href="#Dddmp_cuddBddLoad">Dddmp_cuddBddLoad</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiBdd.c"TARGET="ABSTRACT"><CODE>ddiBdd.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddMakeClustered"></A>
Ddi_Bdd_t * <I></I>
<B>Ddi_BddMakeClustered</B>(
  Ddi_Bdd_t * <b>f</b>, <i>input function</i>
  int  <b>threshold</b> <i>size threshold</i>
)
</pre>
<dd> Create a clustered BDD from a partitioned one. 
    Conjunctions/disjunctions are executed up to the size threshold
    (sizes greater than threshold are aborted).
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiBdd.c"TARGET="ABSTRACT"><CODE>ddiBdd.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddMakeConst"></A>
Ddi_Bdd_t * <I></I>
<B>Ddi_BddMakeConst</B>(
  Ddi_Mgr_t * <b>mgr</b>, <i></i>
  int  <b>value</b> <i>non 0: true (one), 0: false (zero)</i>
)
</pre>
<dd> Generate a Ddi_Bdd_t constant node (BDD zero or one).
    The proper constant node within the manager is duplicated.
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_BddToCU">Ddi_BddToCU</a>
<a href="#DdiBddMakeLiteral">DdiBddMakeLiteral</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiBdd.c"TARGET="ABSTRACT"><CODE>ddiBdd.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddMakeFromCU"></A>
Ddi_Bdd_t * <I></I>
<B>Ddi_BddMakeFromCU</B>(
  Ddi_Mgr_t * <b>mgr</b>, <i></i>
  DdNode * <b>bdd</b> <i></i>
)
</pre>
<dd> Build the Ddi_Bdd_t structure (by means of DdiGenericAlloc)
               from manager and CUDD node.
               The reference count of the node is increased.
<p>

<dd> <b>See Also</b> <code><a href="#DdiGenericAlloc">DdiGenericAlloc</a>
<a href="#Ddi_BddToCU">Ddi_BddToCU</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiBdd.c"TARGET="ABSTRACT"><CODE>ddiBdd.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddMakeFromMeta"></A>
Ddi_Bdd_t * <I></I>
<B>Ddi_BddMakeFromMeta</B>(
  Ddi_Bdd_t * <b>f</b> <i></i>
)
</pre>
<dd> Transform a BDD to Meta BDD. Result generated
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiMeta.c"TARGET="ABSTRACT"><CODE>ddiMeta.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddMakeLiteral"></A>
Ddi_Bdd_t * <I></I>
<B>Ddi_BddMakeLiteral</B>(
  Ddi_Var_t * <b>v</b>, <i></i>
  int  <b>polarity</b> <i>non 0: affirmed (v), 0: complemented literal (!v)</i>
)
</pre>
<dd> Generate a literal from a variable.
    The literal can be either affirmed or complemented.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_Bdd">Ddi_Bdd</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiBdd.c"TARGET="ABSTRACT"><CODE>ddiBdd.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddMakeMeta"></A>
Ddi_Bdd_t * <I></I>
<B>Ddi_BddMakeMeta</B>(
  Ddi_Bdd_t * <b>f</b> <i></i>
)
</pre>
<dd> Transform a BDD to Meta BDD. Result generated
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiMeta.c"TARGET="ABSTRACT"><CODE>ddiMeta.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddMakeMono"></A>
Ddi_Bdd_t * <I></I>
<B>Ddi_BddMakeMono</B>(
  Ddi_Bdd_t * <b>f</b> <i>input function</i>
)
</pre>
<dd> Create a monolithic BDD from a partitioned one
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiBdd.c"TARGET="ABSTRACT"><CODE>ddiBdd.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddMakePartConjFromArray"></A>
Ddi_Bdd_t * <I></I>
<B>Ddi_BddMakePartConjFromArray</B>(
  Ddi_Bddarray_t * <b>array</b> <i></i>
)
</pre>
<dd> Build a conjunctively partitioned BDD from array of partitions
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_BddMakePartConjFromMono">Ddi_BddMakePartConjFromMono</a>
<a href="#Ddi_BddMakePartDisjFromMono">Ddi_BddMakePartDisjFromMono</a>
<a href="#Ddi_BddMakePartDisjFromArray">Ddi_BddMakePartDisjFromArray</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiBdd.c"TARGET="ABSTRACT"><CODE>ddiBdd.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddMakePartConjFromMono"></A>
Ddi_Bdd_t * <I></I>
<B>Ddi_BddMakePartConjFromMono</B>(
  Ddi_Bdd_t * <b>mono</b> <i></i>
)
</pre>
<dd> Build a conjunctively partitioned BDD from a monolithic BDD
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_BddMakePartDisjFromMono">Ddi_BddMakePartDisjFromMono</a>
<a href="#Ddi_BddMakePartConjFromArray">Ddi_BddMakePartConjFromArray</a>
<a href="#Ddi_BddMakePartDisjFromArray">Ddi_BddMakePartDisjFromArray</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiBdd.c"TARGET="ABSTRACT"><CODE>ddiBdd.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddMakePartConjVoid"></A>
Ddi_Bdd_t * <I></I>
<B>Ddi_BddMakePartConjVoid</B>(
  Ddi_Mgr_t * <b>mgr</b> <i></i>
)
</pre>
<dd> Build a conjunctively partitioned BDD with 0 partitions
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_BddMakePartDisjVoid">Ddi_BddMakePartDisjVoid</a>
<a href="#Ddi_BddMakePartConjFromMono">Ddi_BddMakePartConjFromMono</a>
<a href="#Ddi_BddMakePartConjFromArray">Ddi_BddMakePartConjFromArray</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiBdd.c"TARGET="ABSTRACT"><CODE>ddiBdd.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddMakePartDisjFromArray"></A>
Ddi_Bdd_t * <I></I>
<B>Ddi_BddMakePartDisjFromArray</B>(
  Ddi_Bddarray_t * <b>array</b> <i></i>
)
</pre>
<dd> Build a disjunctively partitioned BDD from array of BDDs
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_BddMakePartConjFromMono">Ddi_BddMakePartConjFromMono</a>
<a href="#Ddi_BddMakePartDisjFromMono">Ddi_BddMakePartDisjFromMono</a>
<a href="#Ddi_BddMakePartConjFromArray">Ddi_BddMakePartConjFromArray</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiBdd.c"TARGET="ABSTRACT"><CODE>ddiBdd.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddMakePartDisjFromMono"></A>
Ddi_Bdd_t * <I></I>
<B>Ddi_BddMakePartDisjFromMono</B>(
  Ddi_Bdd_t * <b>mono</b> <i></i>
)
</pre>
<dd> Build a disjunctively partitioned BDD from a monolithic BDD
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_BddMakePartConjFromMono">Ddi_BddMakePartConjFromMono</a>
<a href="#Ddi_BddMakePartConjFromArray">Ddi_BddMakePartConjFromArray</a>
<a href="#Ddi_BddMakePartDisjFromArray">Ddi_BddMakePartDisjFromArray</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiBdd.c"TARGET="ABSTRACT"><CODE>ddiBdd.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddMakePartDisjVoid"></A>
Ddi_Bdd_t * <I></I>
<B>Ddi_BddMakePartDisjVoid</B>(
  Ddi_Mgr_t * <b>mgr</b> <i></i>
)
</pre>
<dd> Build a disjunctively partitioned BDD with 0 partitions
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_BddMakePartConjVoid">Ddi_BddMakePartConjVoid</a>
<a href="#Ddi_BddMakePartDisjFromMono">Ddi_BddMakePartDisjFromMono</a>
<a href="#Ddi_BddMakePartDisjFromArray">Ddi_BddMakePartDisjFromArray</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiBdd.c"TARGET="ABSTRACT"><CODE>ddiBdd.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddNandAcc"></A>
Ddi_Bdd_t * <I></I>
<B>Ddi_BddNandAcc</B>(
  Ddi_Bdd_t * <b>f</b>, <i></i>
  Ddi_Bdd_t * <b>g</b> <i></i>
)
</pre>
<dd> Boolean NAND (!(f&g)). New result is accumulated
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_BddAndAcc">Ddi_BddAndAcc</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiBdd.c"TARGET="ABSTRACT"><CODE>ddiBdd.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddNand"></A>
Ddi_Bdd_t * <I></I>
<B>Ddi_BddNand</B>(
  Ddi_Bdd_t * <b>f</b>, <i></i>
  Ddi_Bdd_t * <b>g</b> <i></i>
)
</pre>
<dd> Boolean NAND (!(f&g)). New result is generated
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_BddAnd">Ddi_BddAnd</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiBdd.c"TARGET="ABSTRACT"><CODE>ddiBdd.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddNorAcc"></A>
Ddi_Bdd_t * <I></I>
<B>Ddi_BddNorAcc</B>(
  Ddi_Bdd_t * <b>f</b>, <i></i>
  Ddi_Bdd_t * <b>g</b> <i></i>
)
</pre>
<dd> Boolean NOR (!(f|g)). New result is accumulated
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_BddAndAcc">Ddi_BddAndAcc</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiBdd.c"TARGET="ABSTRACT"><CODE>ddiBdd.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddNor"></A>
Ddi_Bdd_t * <I></I>
<B>Ddi_BddNor</B>(
  Ddi_Bdd_t * <b>f</b>, <i></i>
  Ddi_Bdd_t * <b>g</b> <i></i>
)
</pre>
<dd> Boolean NOR (!(f|g)). New result is generated
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_BddAnd">Ddi_BddAnd</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiBdd.c"TARGET="ABSTRACT"><CODE>ddiBdd.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddNotAcc"></A>
Ddi_Bdd_t * <I></I>
<B>Ddi_BddNotAcc</B>(
  Ddi_Bdd_t * <b>f</b> <i></i>
)
</pre>
<dd> Boolean NOT. Result is accumulated
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_BddAndAcc">Ddi_BddAndAcc</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiBdd.c"TARGET="ABSTRACT"><CODE>ddiBdd.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddNot"></A>
Ddi_Bdd_t * <I></I>
<B>Ddi_BddNot</B>(
  Ddi_Bdd_t * <b>f</b> <i></i>
)
</pre>
<dd> Boolean NOT. New result is generated
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_BddAnd">Ddi_BddAnd</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiBdd.c"TARGET="ABSTRACT"><CODE>ddiBdd.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddOperation"></A>
int <I></I>
<B>Ddi_BddOperation</B>(
  Ddi_Mgr_t * <b>defaultDdMgr</b>, <i>Default DD Manager</i>
  Ddi_Bdd_t ** <b>bddP</b>, <i>BDD Pointer to manipulate</i>
  char * <b>string</b>, <i>String</i>
  Pdtutil_MgrOp_t  <b>operationFlag</b>, <i>Operation Flag</i>
  void ** <b>voidPointer</b>, <i>Generic Pointer</i>
  Pdtutil_MgrRet_t * <b>returnFlag</b> <i>Type of the Pointer Returned</i>
)
</pre>
<dd> 
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiNew.c"TARGET="ABSTRACT"><CODE>ddiNew.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddOrAcc"></A>
Ddi_Bdd_t * <I></I>
<B>Ddi_BddOrAcc</B>(
  Ddi_Bdd_t * <b>f</b>, <i></i>
  Ddi_Bdd_t * <b>g</b> <i></i>
)
</pre>
<dd> Boolean OR (f|g). New result is accumulated
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_BddAndAcc">Ddi_BddAndAcc</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiBdd.c"TARGET="ABSTRACT"><CODE>ddiBdd.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddOr"></A>
Ddi_Bdd_t * <I></I>
<B>Ddi_BddOr</B>(
  Ddi_Bdd_t * <b>f</b>, <i></i>
  Ddi_Bdd_t * <b>g</b> <i></i>
)
</pre>
<dd> Boolean OR (f|g). New result is generated
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_BddAnd">Ddi_BddAnd</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiBdd.c"TARGET="ABSTRACT"><CODE>ddiBdd.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddPartExtract"></A>
Ddi_Bdd_t * <I></I>
<B>Ddi_BddPartExtract</B>(
  Ddi_Bdd_t * <b>f</b>, <i></i>
  int  <b>i</b> <i></i>
)
</pre>
<dd> Return the i-th partition (conj/disj), and remove it from f.
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiBdd.c"TARGET="ABSTRACT"><CODE>ddiBdd.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddPartInsertLast"></A>
Ddi_Bdd_t * <I></I>
<B>Ddi_BddPartInsertLast</B>(
  Ddi_Bdd_t * <b>f</b>, <i>partitioned BDD</i>
  Ddi_Bdd_t * <b>newp</b> <i>new partition</i>
)
</pre>
<dd> Add new partition at last position. Result accumulated
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_BddPartInsert">Ddi_BddPartInsert</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiBdd.c"TARGET="ABSTRACT"><CODE>ddiBdd.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddPartInsert"></A>
Ddi_Bdd_t * <I></I>
<B>Ddi_BddPartInsert</B>(
  Ddi_Bdd_t * <b>f</b>, <i>partitioned BDD</i>
  int  <b>i</b>, <i>position of new partition</i>
  Ddi_Bdd_t * <b>newp</b> <i>new partition</i>
)
</pre>
<dd> Add new partition at position i. Result accumulated.
    Higher partitions are shifted.
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_BddPartWrite">Ddi_BddPartWrite</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiBdd.c"TARGET="ABSTRACT"><CODE>ddiBdd.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddPartNum"></A>
int <I></I>
<B>Ddi_BddPartNum</B>(
  Ddi_Bdd_t * <b>f</b> <i></i>
)
</pre>
<dd> Read the number of partitions (conj/disj).
    In case of monolithic BDD, 1 is returned, in case of partitioned
    BDDs, the number of partitions.
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiBdd.c"TARGET="ABSTRACT"><CODE>ddiBdd.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddPartRead"></A>
Ddi_Bdd_t * <I></I>
<B>Ddi_BddPartRead</B>(
  Ddi_Bdd_t * <b>f</b>, <i></i>
  int  <b>i</b> <i></i>
)
</pre>
<dd> Read the i-th partition (conj/disj) of f.
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiBdd.c"TARGET="ABSTRACT"><CODE>ddiBdd.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddPartWrite"></A>
Ddi_Bdd_t * <I></I>
<B>Ddi_BddPartWrite</B>(
  Ddi_Bdd_t * <b>f</b>, <i>partitioned BDD</i>
  int  <b>i</b>, <i>position of new partition</i>
  Ddi_Bdd_t * <b>newp</b> <i>new partition</i>
)
</pre>
<dd> Write new partition at position i. Result accumulated.
    Same as insert if position is PartNum+1. Otherwise i-th partition is
    freed and overwritten, so Write is acrually a partition "replace" or
    "rewrite" operation.
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_BddPartInsert">Ddi_BddPartInsert</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiBdd.c"TARGET="ABSTRACT"><CODE>ddiBdd.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddPickOneCubeAcc"></A>
Ddi_Bdd_t * <I></I>
<B>Ddi_BddPickOneCubeAcc</B>(
  Ddi_Bdd_t * <b>f</b> <i></i>
)
</pre>
<dd> Pick one random on-set cube. Result is accumulated
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_BddAndAcc">Ddi_BddAndAcc</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiBdd.c"TARGET="ABSTRACT"><CODE>ddiBdd.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddPickOneCube"></A>
Ddi_Bdd_t * <I></I>
<B>Ddi_BddPickOneCube</B>(
  Ddi_Bdd_t * <b>f</b> <i></i>
)
</pre>
<dd> Pick one random on-set cube. Result is generated
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_BddAnd">Ddi_BddAnd</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiBdd.c"TARGET="ABSTRACT"><CODE>ddiBdd.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddPickOneMintermAcc"></A>
Ddi_Bdd_t * <I></I>
<B>Ddi_BddPickOneMintermAcc</B>(
  Ddi_Bdd_t * <b>f</b>, <i></i>
  Ddi_Varset_t * <b>vars</b> <i>set of variables defining the minterm space</i>
)
</pre>
<dd> Pick one random on-set minterm. Result is accumulated
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_BddAnd">Ddi_BddAnd</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiBdd.c"TARGET="ABSTRACT"><CODE>ddiBdd.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddPickOneMinterm"></A>
Ddi_Bdd_t * <I></I>
<B>Ddi_BddPickOneMinterm</B>(
  Ddi_Bdd_t * <b>f</b>, <i></i>
  Ddi_Varset_t * <b>vars</b> <i>set of variables defining the minterm space</i>
)
</pre>
<dd> Pick one random on-set minterm. Result is generated
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_BddAnd">Ddi_BddAnd</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiBdd.c"TARGET="ABSTRACT"><CODE>ddiBdd.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddPrintCubeToString"></A>
int <I></I>
<B>Ddi_BddPrintCubeToString</B>(
  Ddi_Bdd_t * <b>f</b>, <i>BDD</i>
  Ddi_Varset_t * <b>vars</b>, <i>Variables</i>
  char * <b>string</b> <i>output string</i>
)
</pre>
<dd> Output a cube to string. Return true if succesful.
    The set of variables to be considered
    is given as input (if NULL, true support is used). 
    Variables are sorted by absolute index (which is constant across sifting),
    NOT by variable ordering.
    The procedure allows omitting variables in the true support, which
    are existentially quantified out by cube.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiBdd.c"TARGET="ABSTRACT"><CODE>ddiBdd.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddPrintCubes"></A>
int <I></I>
<B>Ddi_BddPrintCubes</B>(
  Ddi_Bdd_t * <b>f</b>, <i>BDD</i>
  Ddi_Varset_t * <b>vars</b>, <i>Variables</i>
  int  <b>cubeNumberMax</b>, <i>Maximum number of cubes printed</i>
  int  <b>formatPla</b>, <i>Prints a 1 at the end of the cube (PLA format)</i>
  char * <b>filename</b>, <i>File Name</i>
  FILE * <b>fp</b> <i>Pointer to the store file</i>
)
</pre>
<dd> This function outputs the cubes of a BDD on file.
    Only monolithic BDDs are supported. The set of variables to be considered
    is given as input (if NULL the true support is used), to allow generating
    don't cares, data are sorted by absolute index, NOT by variable ordering.
    The procedure allows omitting variables in the true support, which
    are existentially quantified out before generating cubes, to avoid 
    repetitions.
    A limit on the number of cubes generated can be specified.
    Use a negative value for no bound.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiBdd.c"TARGET="ABSTRACT"><CODE>ddiBdd.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddPrintStats"></A>
void <I></I>
<B>Ddi_BddPrintStats</B>(
  Ddi_Bdd_t * <b>f</b>, <i></i>
  FILE * <b>fp</b> <i></i>
)
</pre>
<dd> Prints Statistics of a BDD
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiBdd.c"TARGET="ABSTRACT"><CODE>ddiBdd.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddPrintSupportAndCubes"></A>
int <I></I>
<B>Ddi_BddPrintSupportAndCubes</B>(
  Ddi_Bdd_t * <b>f</b>, <i>BDD</i>
  int  <b>numberPerRow</b>, <i>Number of Names Printed on a Single Row</i>
  int  <b>cubeNumberMax</b>, <i>Maximum number of cubes printed</i>
  int  <b>formatPla</b>, <i>Prints a 1 at the end of the cube (PLA format)</i>
  char * <b>filename</b>, <i>File Name</i>
  FILE * <b>fp</b> <i>Pointer to the store file</i>
)
</pre>
<dd> Use a negative value to indicate no bound in the number of
    printed cubes.
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiUtil.c"TARGET="ABSTRACT"><CODE>ddiUtil.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddPrint"></A>
void <I></I>
<B>Ddi_BddPrint</B>(
  Ddi_Bdd_t * <b>f</b>, <i></i>
  FILE * <b>fp</b> <i></i>
)
</pre>
<dd> Prints a BDD
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiBdd.c"TARGET="ABSTRACT"><CODE>ddiBdd.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddRelMakeFromArray"></A>
Ddi_Bdd_t * <I></I>
<B>Ddi_BddRelMakeFromArray</B>(
  Ddi_Bddarray_t * <b>Fa</b>, <i>array of functions</i>
  Ddi_Vararray_t * <b>Va</b> <i>array of range variables</i>
)
</pre>
<dd> Generate a Ddi_Bdd_t relation from array of functions. 
    Relation is generated considering function variables domain, 
    and range variables as co-domain.
    I-th range variable corresponds to i-th function.
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiBdd.c"TARGET="ABSTRACT"><CODE>ddiBdd.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddRestrictAcc"></A>
Ddi_Bdd_t * <I></I>
<B>Ddi_BddRestrictAcc</B>(
  Ddi_Bdd_t * <b>f</b>, <i></i>
  Ddi_Bdd_t * <b>g</b> <i></i>
)
</pre>
<dd> Restrict cofactor. New result is accumulated
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_BddAndAcc">Ddi_BddAndAcc</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiBdd.c"TARGET="ABSTRACT"><CODE>ddiBdd.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddRestrict"></A>
Ddi_Bdd_t * <I></I>
<B>Ddi_BddRestrict</B>(
  Ddi_Bdd_t * <b>f</b>, <i></i>
  Ddi_Bdd_t * <b>g</b> <i></i>
)
</pre>
<dd> Restrict cofactor. New result is generated
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_BddAnd">Ddi_BddAnd</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiBdd.c"TARGET="ABSTRACT"><CODE>ddiBdd.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddSetClustered"></A>
Ddi_Bdd_t * <I></I>
<B>Ddi_BddSetClustered</B>(
  Ddi_Bdd_t * <b>f</b>, <i>input function</i>
  int  <b>threshold</b> <i>size threshold</i>
)
</pre>
<dd> Create a clustered BDD from a partitioned one. 
    Conjunctions/disjunctions are executed up to the size threshold
    (sizes greater than threshold are aborted).
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiBdd.c"TARGET="ABSTRACT"><CODE>ddiBdd.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddSetMeta"></A>
Ddi_Bdd_t * <I></I>
<B>Ddi_BddSetMeta</B>(
  Ddi_Bdd_t * <b>f</b> <i></i>
)
</pre>
<dd> Transform a BDD to Meta BDD. Result accumulated
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiMeta.c"TARGET="ABSTRACT"><CODE>ddiMeta.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddSetMono"></A>
Ddi_Bdd_t * <I></I>
<B>Ddi_BddSetMono</B>(
  Ddi_Bdd_t * <b>f</b> <i>input function</i>
)
</pre>
<dd> Convert a BDD to monolitic (if required). Result accumulated
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiBdd.c"TARGET="ABSTRACT"><CODE>ddiBdd.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddSetPartConj"></A>
Ddi_Bdd_t * <I></I>
<B>Ddi_BddSetPartConj</B>(
  Ddi_Bdd_t * <b>f</b> <i></i>
)
</pre>
<dd> Convert a BDD to conjunctively partitioned (if required). 
               Result accumulated
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiBdd.c"TARGET="ABSTRACT"><CODE>ddiBdd.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddSetPartDisj"></A>
Ddi_Bdd_t * <I></I>
<B>Ddi_BddSetPartDisj</B>(
  Ddi_Bdd_t * <b>f</b> <i></i>
)
</pre>
<dd> Convert a BDD to disjunctively partitioned (if required). 
               Result accumulated
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiBdd.c"TARGET="ABSTRACT"><CODE>ddiBdd.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddSize"></A>
int <I></I>
<B>Ddi_BddSize</B>(
  Ddi_Bdd_t * <b>f</b> <i></i>
)
</pre>
<dd> Return BDD size (total amount of BDD nodes) of f.
    In case of partitioned or meta BDDs the sharing size is returned
    (shared subgraphs are counted once).
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiBdd.c"TARGET="ABSTRACT"><CODE>ddiBdd.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddStore"></A>
int <I></I>
<B>Ddi_BddStore</B>(
  Ddi_Bdd_t * <b>f</b>, <i>BDD</i>
  char * <b>ddname</b>, <i>dd name (or NULL)</i>
  char  <b>mode</b>, <i>storing mode</i>
  char * <b>filename</b>, <i>file name</i>
  FILE * <b>fp</b> <i>pointer to the store file</i>
)
</pre>
<dd> This function stores only a BDD (not a BDD array).
    The BDD is stored in the DDDMP format. The parameter "mode" 
    can be DDDMP_MODE_TEXT, DDDMP_MODE_BINARY or
    DDDMP_MODE_DEFAULT.<br>
    The function returns 1 if succefully stored, 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_BddLoad">Ddi_BddLoad</a>
<a href="#Dddmp_cuddBddStore">Dddmp_cuddBddStore</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiBdd.c"TARGET="ABSTRACT"><CODE>ddiBdd.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddSubstVarsAcc"></A>
Ddi_Bdd_t * <I></I>
<B>Ddi_BddSubstVarsAcc</B>(
  Ddi_Bdd_t * <b>f</b>, <i></i>
  Ddi_Vararray_t * <b>x</b>, <i>1-st array of variables</i>
  Ddi_Vararray_t * <b>y</b> <i>2-nd array of variables</i>
)
</pre>
<dd> Variable substitution x <- y in f. New result is accumulated.  
               Variable correspondence is established by position in x, y.
               Substitution is done by compose. This differs from variable 
               swapping since some y vars may be present in x as well as in 
               the support of f.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_BddSwapVars">Ddi_BddSwapVars</a>
<a href="#Ddi_BddSubstVars">Ddi_BddSubstVars</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiBdd.c"TARGET="ABSTRACT"><CODE>ddiBdd.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddSubstVars"></A>
Ddi_Bdd_t * <I></I>
<B>Ddi_BddSubstVars</B>(
  Ddi_Bdd_t * <b>f</b>, <i></i>
  Ddi_Vararray_t * <b>x</b>, <i>1-st array of variables</i>
  Ddi_Vararray_t * <b>y</b> <i>2-nd array of variables</i>
)
</pre>
<dd> Variable substitution x <- y in f. New result is generated.  
               Variable correspondence is established by position in x, y.
               Substitution is done by compose. This differs from variable 
               swapping since some y vars may be present in x as well as in 
               the support of f.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_BddSwapVars">Ddi_BddSwapVars</a>
<a href="#Ddi_BddSubstVarsAcc">Ddi_BddSubstVarsAcc</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiBdd.c"TARGET="ABSTRACT"><CODE>ddiBdd.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddSuppAttach"></A>
Ddi_Bdd_t * <I></I>
<B>Ddi_BddSuppAttach</B>(
  Ddi_Bdd_t * <b>f</b> <i></i>
)
</pre>
<dd> The support of f is the set of variables f depends on.
               This function generates the support of f 
               and hooks it to proper field of f, so that no BDD traversal 
               is done in further calls of Ddi_BddSupp.
<p>

<dd> <b>Side Effects</b> support is attached to f
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_BddSupp">Ddi_BddSupp</a>
<a href="#Ddi_BddSuppDetach">Ddi_BddSuppDetach</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiBdd.c"TARGET="ABSTRACT"><CODE>ddiBdd.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddSuppDetach"></A>
Ddi_Bdd_t * <I></I>
<B>Ddi_BddSuppDetach</B>(
  Ddi_Bdd_t * <b>f</b> <i></i>
)
</pre>
<dd> Detach (and free) support attached to f. Return pointer to f
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_BddSupp">Ddi_BddSupp</a>
<a href="#Ddi_BddSuppAttach">Ddi_BddSuppAttach</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiBdd.c"TARGET="ABSTRACT"><CODE>ddiBdd.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddSuppRead"></A>
Ddi_Varset_t * <I></I>
<B>Ddi_BddSuppRead</B>(
  Ddi_Bdd_t * <b>f</b> <i></i>
)
</pre>
<dd> Read the support attached to a Bdd. The support is not 
    duplicated, as would Ddi_BddSupp with attached support. Return NULL if
    support is not attached.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_BddSupp">Ddi_BddSupp</a>
<a href="#Ddi_BddSuppAttach">Ddi_BddSuppAttach</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiBdd.c"TARGET="ABSTRACT"><CODE>ddiBdd.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddSupp"></A>
Ddi_Varset_t * <I></I>
<B>Ddi_BddSupp</B>(
  Ddi_Bdd_t * <b>f</b> <i></i>
)
</pre>
<dd> The support of f is the set of variables f depends on.
               This function has no "accumulated" version, but a related
               function (Ddi_BddSuppAttach) which attaches the support to
               a function, so that no BDD traversal is done in further
               calls of Ddi_BddSupp.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_BddSuppAttach">Ddi_BddSuppAttach</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiBdd.c"TARGET="ABSTRACT"><CODE>ddiBdd.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddSwapVarsAcc"></A>
Ddi_Bdd_t * <I></I>
<B>Ddi_BddSwapVarsAcc</B>(
  Ddi_Bdd_t * <b>f</b>, <i></i>
  Ddi_Vararray_t * <b>x</b>, <i>1-st array of variables</i>
  Ddi_Vararray_t * <b>y</b> <i>2-nd array of variables</i>
)
</pre>
<dd> Swap x and y variables in f. Result is accumulated
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_BddAnd">Ddi_BddAnd</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiBdd.c"TARGET="ABSTRACT"><CODE>ddiBdd.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddSwapVars"></A>
Ddi_Bdd_t * <I></I>
<B>Ddi_BddSwapVars</B>(
  Ddi_Bdd_t * <b>f</b>, <i></i>
  Ddi_Vararray_t * <b>x</b>, <i>1-st array of variables</i>
  Ddi_Vararray_t * <b>y</b> <i>2-nd array of variables</i>
)
</pre>
<dd> Swap x and y variables in f. New result is generated
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_BddAnd">Ddi_BddAnd</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiBdd.c"TARGET="ABSTRACT"><CODE>ddiBdd.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddToCU"></A>
Ddi_BddNode * <I></I>
<B>Ddi_BddToCU</B>(
  Ddi_Bdd_t * <b>f</b> <i></i>
)
</pre>
<dd> Convert a DDI function to the corresponding Cudd Node.
    This is done by reading the proper field (pointing to a cudd node) in the 
    DDI node. No ref is done on the returned node.
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_BddMakeFromCU">Ddi_BddMakeFromCU</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiBdd.c"TARGET="ABSTRACT"><CODE>ddiBdd.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddTopVar"></A>
Ddi_Var_t * <I></I>
<B>Ddi_BddTopVar</B>(
  Ddi_Bdd_t * <b>f</b> <i></i>
)
</pre>
<dd> Return the top BDD variable of f
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiBdd.c"TARGET="ABSTRACT"><CODE>ddiBdd.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddXnorAcc"></A>
Ddi_Bdd_t * <I></I>
<B>Ddi_BddXnorAcc</B>(
  Ddi_Bdd_t * <b>f</b>, <i></i>
  Ddi_Bdd_t * <b>g</b> <i></i>
)
</pre>
<dd> Boolean XNOR (!(f^g)). New result is accumulated
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_BddAndAcc">Ddi_BddAndAcc</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiBdd.c"TARGET="ABSTRACT"><CODE>ddiBdd.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddXnor"></A>
Ddi_Bdd_t * <I></I>
<B>Ddi_BddXnor</B>(
  Ddi_Bdd_t * <b>f</b>, <i></i>
  Ddi_Bdd_t * <b>g</b> <i></i>
)
</pre>
<dd> Boolean XNOR (!(f^g)). New result is generated
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_BddAnd">Ddi_BddAnd</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiBdd.c"TARGET="ABSTRACT"><CODE>ddiBdd.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddXorAcc"></A>
Ddi_Bdd_t * <I></I>
<B>Ddi_BddXorAcc</B>(
  Ddi_Bdd_t * <b>f</b>, <i></i>
  Ddi_Bdd_t * <b>g</b> <i></i>
)
</pre>
<dd> Boolean XOR (f^g). New result is accumulated
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_BddAndAcc">Ddi_BddAndAcc</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiBdd.c"TARGET="ABSTRACT"><CODE>ddiBdd.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddXor"></A>
Ddi_Bdd_t * <I></I>
<B>Ddi_BddXor</B>(
  Ddi_Bdd_t * <b>f</b>, <i></i>
  Ddi_Bdd_t * <b>g</b> <i></i>
)
</pre>
<dd> Boolean XOR (f^g). New result is generated
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_BddAnd">Ddi_BddAnd</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiBdd.c"TARGET="ABSTRACT"><CODE>ddiBdd.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddarrayAlloc"></A>
Ddi_Bddarray_t * <I></I>
<B>Ddi_BddarrayAlloc</B>(
  Ddi_Mgr_t * <b>mgr</b>, <i>DDI manager</i>
  int  <b>length</b> <i>array length</i>
)
</pre>
<dd> Allocate a new array of BDDs. The array slots are initialized 
    with NULL pointers, so further Write operations are required.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_BddarrayWrite">Ddi_BddarrayWrite</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiBddarray.c"TARGET="ABSTRACT"><CODE>ddiBddarray.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddarrayAppend"></A>
void <I></I>
<B>Ddi_BddarrayAppend</B>(
  Ddi_Bddarray_t * <b>array1</b>, <i>first array</i>
  Ddi_Bddarray_t * <b>array2</b> <i>array to be appended</i>
)
</pre>
<dd> Append the elements of array2 at the end of array1. As all
    array write/insert operations, new entries are duplicated.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_BddarrayWrite">Ddi_BddarrayWrite</a>
<a href="#Ddi_BddarrayInsert">Ddi_BddarrayInsert</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiBddarray.c"TARGET="ABSTRACT"><CODE>ddiBddarray.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddarrayClear"></A>
void <I></I>
<B>Ddi_BddarrayClear</B>(
  Ddi_Bddarray_t * <b>array</b>, <i>array of BDDs</i>
  int  <b>pos</b> <i>position of element to be cleared</i>
)
</pre>
<dd> clear array at given position (BDD freed and replaced by NULL)
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_BddarrayRead">Ddi_BddarrayRead</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiBddarray.c"TARGET="ABSTRACT"><CODE>ddiBddarray.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddarrayCopy"></A>
Ddi_Bddarray_t * <I></I>
<B>Ddi_BddarrayCopy</B>(
  Ddi_BddMgr * <b>ddm</b>, <i>dd Manager</i>
  Ddi_Bddarray_t * <b>old</b> <i>array of BDDs</i>
)
</pre>
<dd> Copy an array of BDDs to a destination manager.
    Variable correspondence is established "by index", i.e. 
    variables with same index in different manager correspond
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_BddarrayDup">Ddi_BddarrayDup</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiBddarray.c"TARGET="ABSTRACT"><CODE>ddiBddarray.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddarrayDup"></A>
Ddi_Bddarray_t * <I></I>
<B>Ddi_BddarrayDup</B>(
  Ddi_Bddarray_t * <b>old</b> <i>array to be duplicated</i>
)
</pre>
<dd> Duplicate an array of BDDs
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_BddarrayAlloc">Ddi_BddarrayAlloc</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiBddarray.c"TARGET="ABSTRACT"><CODE>ddiBddarray.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddarrayExtract"></A>
Ddi_Bdd_t * <I></I>
<B>Ddi_BddarrayExtract</B>(
  Ddi_Bddarray_t * <b>array</b>, <i>BDD array</i>
  int  <b>i</b> <i>position</i>
)
</pre>
<dd> Extract the BDD at i-th position in array. 
    The extracted BDD is removed from the array and the following entries
    are shifted up.
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_BddarrayInsert">Ddi_BddarrayInsert</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiBddarray.c"TARGET="ABSTRACT"><CODE>ddiBddarray.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddarrayInsertLast"></A>
void <I></I>
<B>Ddi_BddarrayInsertLast</B>(
  Ddi_Bddarray_t * <b>array</b>, <i>array of BDDs</i>
  Ddi_Bdd_t * <b>f</b> <i>BDD to be written</i>
)
</pre>
<dd> Insert a BDD in array at last (new) position
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_BddarrayExtract">Ddi_BddarrayExtract</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiBddarray.c"TARGET="ABSTRACT"><CODE>ddiBddarray.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddarrayInsert"></A>
void <I></I>
<B>Ddi_BddarrayInsert</B>(
  Ddi_Bddarray_t * <b>array</b>, <i>array of BDDs</i>
  int  <b>pos</b>, <i>position of new element</i>
  Ddi_Bdd_t * <b>f</b> <i>BDD to be written</i>
)
</pre>
<dd> Insert a BDD in array at given position. 
    Following entries are shifted down.
    The written BDD (f) is duplicated
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_BddarrayExtract">Ddi_BddarrayExtract</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiBddarray.c"TARGET="ABSTRACT"><CODE>ddiBddarray.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddarrayLoad"></A>
Ddi_Bddarray_t * <I></I>
<B>Ddi_BddarrayLoad</B>(
  Ddi_BddMgr * <b>dd</b>, <i>dd manager</i>
  char ** <b>vnames</b>, <i>variable names</i>
  int * <b>vauxids</b>, <i>variable auxids</i>
  int  <b>mode</b>, <i>storing mode selector</i>
  char * <b>file</b>, <i>name file</i>
  FILE * <b>fp</b> <i>file pointer</i>
)
</pre>
<dd> This function loads a BDDs'array.<br>
               The BDD on file must be in the DDDMP format. The parameter 
               "mode" can be DDDMP_MODE_TEXT, DDDMP_MODE_COMPRESSED or
               DDDMP_MODE_AUTOMATIC.<br>
               The function returns the pointer of array if succefully
               loaded, NULL otherwise.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Dddmp_cuddBddLoad">Dddmp_cuddBddLoad</a>
<a href="#Ddi_BddLoad">Ddi_BddLoad</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiBddarray.c"TARGET="ABSTRACT"><CODE>ddiBddarray.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddarrayMakeFromBddPart"></A>
Ddi_Bddarray_t * <I></I>
<B>Ddi_BddarrayMakeFromBddPart</B>(
  Ddi_Bdd_t * <b>part</b> <i></i>
)
</pre>
<dd> Generate a BDD array from partitions of partitioned BDD
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_BddarrayToCU">Ddi_BddarrayToCU</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiBddarray.c"TARGET="ABSTRACT"><CODE>ddiBddarray.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddarrayMakeFromCU"></A>
Ddi_Bddarray_t * <I></I>
<B>Ddi_BddarrayMakeFromCU</B>(
  Ddi_Mgr_t * <b>mgr</b>, <i></i>
  DdNode ** <b>array</b>, <i></i>
  int  <b>n</b> <i></i>
)
</pre>
<dd> Generate a BDD array from CUDD BDDs.
    The function allocates a Ddi_Bddarray_t structure, then write 
    monolithic components to proper array slots.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_BddarrayToCU">Ddi_BddarrayToCU</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiBddarray.c"TARGET="ABSTRACT"><CODE>ddiBddarray.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddarrayMakeMeta"></A>
Ddi_Bddarray_t * <I></I>
<B>Ddi_BddarrayMakeMeta</B>(
  Ddi_Bddarray_t * <b>f</b> <i></i>
)
</pre>
<dd> Transform a BDD array to Meta BDD. Result generated
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiMeta.c"TARGET="ABSTRACT"><CODE>ddiMeta.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddarrayNum"></A>
int <I></I>
<B>Ddi_BddarrayNum</B>(
  Ddi_Bddarray_t * <b>array</b> <i></i>
)
</pre>
<dd> Return the number of BDDs (entries) in array
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiBddarray.c"TARGET="ABSTRACT"><CODE>ddiBddarray.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddarrayOperation"></A>
int <I></I>
<B>Ddi_BddarrayOperation</B>(
  Ddi_Mgr_t * <b>defaultDdMgr</b>, <i>Default BDD Manager</i>
  Ddi_Bddarray_t ** <b>bddArrayP</b>, <i>BDD Array Pointer to manipulate</i>
  char * <b>string</b>, <i>String</i>
  Pdtutil_MgrOp_t  <b>operationFlag</b>, <i>Operation Flag</i>
  void ** <b>voidPointer</b>, <i>Generic Pointer</i>
  Pdtutil_MgrRet_t * <b>returnFlag</b> <i>Type of the Pointer Returned</i>
)
</pre>
<dd> 
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiNew.c"TARGET="ABSTRACT"><CODE>ddiNew.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddarrayPrintSupportAndCubes"></A>
int <I></I>
<B>Ddi_BddarrayPrintSupportAndCubes</B>(
  Ddi_Bddarray_t * <b>fArray</b>, <i>BDD Array</i>
  int  <b>numberPerRow</b>, <i>Number of Names Printed on a Single Row</i>
  int  <b>cubeNumberMax</b>, <i>Maximum number of cubes printed</i>
  int  <b>formatPla</b>, <i>Prints a 1 at the end of the cube (PLA format)</i>
  int  <b>reverse</b>, <i>Reverse Order if 1</i>
  char * <b>filename</b>, <i>File Name</i>
  FILE * <b>fp</b> <i>Pointer to the store file</i>
)
</pre>
<dd> Use a negative value to indicate no bound in the number of
    printed cubes.
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiUtil.c"TARGET="ABSTRACT"><CODE>ddiUtil.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddarrayRead"></A>
Ddi_Bdd_t * <I></I>
<B>Ddi_BddarrayRead</B>(
  Ddi_Bddarray_t * <b>array</b>, <i>BDD array</i>
  int  <b>i</b> <i>position</i>
)
</pre>
<dd> Read the BDD at i-th position in array. As all read operations
    no data duplication is done, so the returned BDD should be duplicated
    if further manipulations are required on it.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_BddarrayWrite">Ddi_BddarrayWrite</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiBddarray.c"TARGET="ABSTRACT"><CODE>ddiBddarray.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddarrayRemove"></A>
void <I></I>
<B>Ddi_BddarrayRemove</B>(
  Ddi_Bddarray_t * <b>array</b>, <i>array of BDDs</i>
  int  <b>pos</b> <i>position of element to be cleared</i>
)
</pre>
<dd> Remove array entry at given position.
    This operation is equivalent to extract + free of extracted BDD.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_BddarrayExtract">Ddi_BddarrayExtract</a>
<a href="#Ddi_BddarrayClear">Ddi_BddarrayClear</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiBddarray.c"TARGET="ABSTRACT"><CODE>ddiBddarray.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddarraySize"></A>
int <I></I>
<B>Ddi_BddarraySize</B>(
  Ddi_Bddarray_t * <b>array</b> <i></i>
)
</pre>
<dd> Count the  numbers of BDD nodes in a BDD array. Shared
    nodes are counted once.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_BddSize">Ddi_BddSize</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiBddarray.c"TARGET="ABSTRACT"><CODE>ddiBddarray.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddarrayStore"></A>
int <I></I>
<B>Ddi_BddarrayStore</B>(
  Ddi_Bddarray_t * <b>array</b>, <i>array to be stored</i>
  char * <b>ddname</b>, <i>dd name (or NULL)</i>
  char ** <b>vnames</b>, <i>array of variable names (or NULL)</i>
  char ** <b>rnames</b>, <i>array of root names (or NULL)</i>
  int * <b>vauxids</b>, <i>array of aux var ids (or NULL)</i>
  int  <b>mode</b>, <i>storing mode selector</i>
  char * <b>fname</b>, <i>file name</i>
  FILE * <b>fp</b> <i>pointer to the store file</i>
)
</pre>
<dd> This function stores a BDD array using the
               DDDMP format. The parameter "mode" 
               can be DDDMP_MODE_TEXT, DDDMP_MODE_COMPRESSED or
               DDDMP_MODE_AUTOMATIC.<br>
               The function returns 1 if succefully stored, 0 otherwise.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Dddmp_cuddBddStore">Dddmp_cuddBddStore</a>
<a href="#Ddi_BddStore">Ddi_BddStore</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiBddarray.c"TARGET="ABSTRACT"><CODE>ddiBddarray.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddarraySuppArray"></A>
Ddi_Varset_t ** <I></I>
<B>Ddi_BddarraySuppArray</B>(
  Ddi_Bddarray_t * <b>fArray</b> <i>array of function</i>
)
</pre>
<dd> OLD(pdt-1). Return a vector of supports of BDD array elements.
    Should be replaced by Varsetarray usage
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiBddarray.c"TARGET="ABSTRACT"><CODE>ddiBddarray.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddarraySupp"></A>
Ddi_Varset_t * <I></I>
<B>Ddi_BddarraySupp</B>(
  Ddi_Bddarray_t * <b>array</b> <i>BDDs'array</i>
)
</pre>
<dd> Returns a var-set representing the global support of the array
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiBddarray.c"TARGET="ABSTRACT"><CODE>ddiBddarray.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddarrayToCU"></A>
DdNode ** <I></I>
<B>Ddi_BddarrayToCU</B>(
  Ddi_Bddarray_t * <b>array</b> <i></i>
)
</pre>
<dd> Generate a dynamically allocated array of pointers to CUDD 
    BDDs, one for each entry in the DDI array. Array entries are required
    to be monolithic.
    The number of array entries is equal to Ddi_BddarrayNum(array), but the 
    array is overdimensioned (by one NULL slot) to make it NULL-terminated.
    The array of pointers is allocated (so explicit free is required), whereas
    the CUDD nodes are NOT referenced.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_BddarrayMakeFromCU">Ddi_BddarrayMakeFromCU</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiBddarray.c"TARGET="ABSTRACT"><CODE>ddiBddarray.c</CODE></A>

<dt><pre>
<A NAME="Ddi_BddarrayWrite"></A>
void <I></I>
<B>Ddi_BddarrayWrite</B>(
  Ddi_Bddarray_t * <b>array</b>, <i>array of BDDs</i>
  int  <b>pos</b>, <i>position of new element</i>
  Ddi_Bdd_t * <b>f</b> <i>BDD to be written</i>
)
</pre>
<dd> Write a BDD in array at given position. Previous non NULL entry
    is freed. The written BDD (f) is duplicated
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_BddarrayRead">Ddi_BddarrayRead</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiBddarray.c"TARGET="ABSTRACT"><CODE>ddiBddarray.c</CODE></A>

<dt><pre>
<A NAME="Ddi_CountMinterm"></A>
double <I></I>
<B>Ddi_CountMinterm</B>(
  Ddi_Bdd_t * <b>f</b>, <i></i>
  int  <b>nvar</b> <i></i>
)
</pre>
<dd> Check for inclusion (f in g). Return non 0 if true.
    This test requires the second operand (g) to be monolithic, whereas
    monolithic and disjunctively partitioned forms are allowed for first
    operand (f).
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiBdd.c"TARGET="ABSTRACT"><CODE>ddiBdd.c</CODE></A>

<dt><pre>
<A NAME="Ddi_DenseMethodEnum2String"></A>
char * <I></I>
<B>Ddi_DenseMethodEnum2String</B>(
  Ddi_DenseMethod_e  <b>enumType</b> <i></i>
)
</pre>
<dd> Given an Enumerated type Returns a string
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiUtil.c"TARGET="ABSTRACT"><CODE>ddiUtil.c</CODE></A>

<dt><pre>
<A NAME="Ddi_DenseMethodString2Enum"></A>
Ddi_DenseMethod_e <I></I>
<B>Ddi_DenseMethodString2Enum</B>(
  char * <b>string</b> <i>String to Analyze</i>
)
</pre>
<dd> It receives a string; to facilitate the user that string
    can be an easy-to-remember predefined code or an integer number
    (interpreted as a string).
    It returns the dense method type.
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiUtil.c"TARGET="ABSTRACT"><CODE>ddiUtil.c</CODE></A>

<dt><pre>
<A NAME="Ddi_ExprBoolMake"></A>
Ddi_Expr_t * <I></I>
<B>Ddi_ExprBoolMake</B>(
  Ddi_Mgr_t * <b>mgr</b>, <i></i>
  Ddi_Expr_t * <b>op1</b>, <i></i>
  Ddi_Expr_t * <b>op2</b> <i></i>
)
</pre>
<dd> Build a Boolean Ddi_Expr_t from given sub-expressions.
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_ExprMakeFromBdd">Ddi_ExprMakeFromBdd</a>
<a href="#Ddi_ExprMakeFromString">Ddi_ExprMakeFromString</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiExpr.c"TARGET="ABSTRACT"><CODE>ddiExpr.c</CODE></A>

<dt><pre>
<A NAME="Ddi_ExprCtlMake"></A>
Ddi_Expr_t * <I></I>
<B>Ddi_ExprCtlMake</B>(
  Ddi_Mgr_t * <b>mgr</b>, <i></i>
  int  <b>opcode</b>, <i></i>
  Ddi_Expr_t * <b>op1</b>, <i></i>
  Ddi_Expr_t * <b>op2</b>, <i></i>
  Ddi_Expr_t * <b>op3</b> <i></i>
)
</pre>
<dd> Build a Ctl Ddi_Expr_t from given sub-expressions.
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_ExprMakeFromBdd">Ddi_ExprMakeFromBdd</a>
<a href="#Ddi_ExprMakeFromString">Ddi_ExprMakeFromString</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiExpr.c"TARGET="ABSTRACT"><CODE>ddiExpr.c</CODE></A>

<dt><pre>
<A NAME="Ddi_ExprDup"></A>
Ddi_Expr_t * <I></I>
<B>Ddi_ExprDup</B>(
  Ddi_Expr_t * <b>f</b> <i>expression to be duplicated</i>
)
</pre>
<dd> Duplicate a Ddi_Expr_t. Duplication is propagated 
    recursively.
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiExpr.c"TARGET="ABSTRACT"><CODE>ddiExpr.c</CODE></A>

<dt><pre>
<A NAME="Ddi_ExprIsTerminal"></A>
int <I></I>
<B>Ddi_ExprIsTerminal</B>(
  Ddi_Expr_t * <b>e</b> <i></i>
)
</pre>
<dd> Return true (non 0) if expression is terminal (Bdd or string).
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiExpr.c"TARGET="ABSTRACT"><CODE>ddiExpr.c</CODE></A>

<dt><pre>
<A NAME="Ddi_ExprLoad"></A>
Ddi_Expr_t * <I></I>
<B>Ddi_ExprLoad</B>(
  Ddi_BddMgr * <b>dd</b>, <i>dd manager</i>
  char * <b>filename</b>, <i>file name</i>
  FILE * <b>fp</b> <i>file pointer</i>
)
</pre>
<dd> Load EXPRESSION from file
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiExpr.c"TARGET="ABSTRACT"><CODE>ddiExpr.c</CODE></A>

<dt><pre>
<A NAME="Ddi_ExprMakeFromBdd"></A>
Ddi_Expr_t * <I></I>
<B>Ddi_ExprMakeFromBdd</B>(
  Ddi_Bdd_t * <b>f</b> <i></i>
)
</pre>
<dd> Build the Ddi_Expr_t structure (by means of DdiGenericAlloc)
               from BDD handle.
<p>

<dd> <b>See Also</b> <code><a href="#DdiGenericAlloc">DdiGenericAlloc</a>
<a href="#Ddi_ExprToBdd">Ddi_ExprToBdd</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiExpr.c"TARGET="ABSTRACT"><CODE>ddiExpr.c</CODE></A>

<dt><pre>
<A NAME="Ddi_ExprMakeFromString"></A>
Ddi_Expr_t * <I></I>
<B>Ddi_ExprMakeFromString</B>(
  Ddi_Mgr_t * <b>mgr</b>, <i></i>
  char * <b>s</b> <i></i>
)
</pre>
<dd> Build a Ddi_Expr_t  from a given string.
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiExpr.c"TARGET="ABSTRACT"><CODE>ddiExpr.c</CODE></A>

<dt><pre>
<A NAME="Ddi_ExprPrint"></A>
void <I></I>
<B>Ddi_ExprPrint</B>(
  Ddi_Expr_t * <b>f</b>, <i></i>
  FILE * <b>fp</b> <i></i>
)
</pre>
<dd> Print a Ddi_Expr_t
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiExpr.c"TARGET="ABSTRACT"><CODE>ddiExpr.c</CODE></A>

<dt><pre>
<A NAME="Ddi_ExprReadOpcode"></A>
int <I></I>
<B>Ddi_ExprReadOpcode</B>(
  Ddi_Expr_t * <b>e</b> <i></i>
)
</pre>
<dd> Read expression opcode
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiExpr.c"TARGET="ABSTRACT"><CODE>ddiExpr.c</CODE></A>

<dt><pre>
<A NAME="Ddi_ExprReadSub"></A>
Ddi_Expr_t * <I></I>
<B>Ddi_ExprReadSub</B>(
  Ddi_Expr_t * <b>e</b>, <i></i>
  int  <b>i</b> <i></i>
)
</pre>
<dd> Rear sub-expression at given position
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiExpr.c"TARGET="ABSTRACT"><CODE>ddiExpr.c</CODE></A>

<dt><pre>
<A NAME="Ddi_ExprSubNum"></A>
int <I></I>
<B>Ddi_ExprSubNum</B>(
  Ddi_Expr_t * <b>e</b> <i></i>
)
</pre>
<dd> Read the number of sub-expressions.
    In case of terminal expressioins (Bdd or String), 0 is returned.
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiExpr.c"TARGET="ABSTRACT"><CODE>ddiExpr.c</CODE></A>

<dt><pre>
<A NAME="Ddi_ExprToBdd"></A>
Ddi_Bdd_t * <I></I>
<B>Ddi_ExprToBdd</B>(
  Ddi_Expr_t * <b>e</b> <i></i>
)
</pre>
<dd> Retrieve the Bdd associated to the expression. 
    Result is NOT duplicated (in other words, the BDD field is read)
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_ExprMakeFromBdd">Ddi_ExprMakeFromBdd</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiExpr.c"TARGET="ABSTRACT"><CODE>ddiExpr.c</CODE></A>

<dt><pre>
<A NAME="Ddi_ExprToString"></A>
char * <I></I>
<B>Ddi_ExprToString</B>(
  Ddi_Expr_t * <b>e</b> <i></i>
)
</pre>
<dd> Retrieve the string associated to the expression.
    Result is NOT duplicated (in other words, the BDD field is read)
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_ExprMakeFromString">Ddi_ExprMakeFromString</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiExpr.c"TARGET="ABSTRACT"><CODE>ddiExpr.c</CODE></A>

<dt><pre>
<A NAME="Ddi_ExprWriteSub"></A>
Ddi_Expr_t * <I></I>
<B>Ddi_ExprWriteSub</B>(
  Ddi_Expr_t * <b>e</b>, <i></i>
  int  <b>pos</b>, <i></i>
  Ddi_Expr_t * <b>op</b> <i></i>
)
</pre>
<dd> Write operand sub-expression to expression at given position. 
    Sub-expression is added if not present, rewritten (by freeing the old one)
    if present at specified position
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_ExprMakeFromBdd">Ddi_ExprMakeFromBdd</a>
<a href="#Ddi_ExprMakeFromString">Ddi_ExprMakeFromString</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiExpr.c"TARGET="ABSTRACT"><CODE>ddiExpr.c</CODE></A>

<dt><pre>
<A NAME="Ddi_GenericDup"></A>
Ddi_Generic_t * <I></I>
<B>Ddi_GenericDup</B>(
  Ddi_Generic_t * <b>f</b> <i></i>
)
</pre>
<dd> Generic dup
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiGeneric.c"TARGET="ABSTRACT"><CODE>ddiGeneric.c</CODE></A>

<dt><pre>
<A NAME="Ddi_GenericFree"></A>
void <I></I>
<B>Ddi_GenericFree</B>(
  Ddi_Generic_t * <b>f</b> <i>block to be freed</i>
)
</pre>
<dd> Free the content of a generic DDI node
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiGeneric.c"TARGET="ABSTRACT"><CODE>ddiGeneric.c</CODE></A>

<dt><pre>
<A NAME="Ddi_GenericLock"></A>
void <I></I>
<B>Ddi_GenericLock</B>(
  Ddi_Generic_t * <b>f</b> <i></i>
)
</pre>
<dd> Lock DDI node so that cannot be freed unless unlocked.
    Used as a protection mechanism for internal objects (array entries,
    partitions, ...
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_GenericUnlock">Ddi_GenericUnlock</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiGeneric.c"TARGET="ABSTRACT"><CODE>ddiGeneric.c</CODE></A>

<dt><pre>
<A NAME="Ddi_GenericOpAcc"></A>
Ddi_Generic_t * <I></I>
<B>Ddi_GenericOpAcc</B>(
  Ddi_OpCode_e  <b>opcode</b>, <i>operation code</i>
  Ddi_Generic_t * <b>f</b>, <i>first operand</i>
  Ddi_Generic_t * <b>g</b>, <i>first operand</i>
  Ddi_Generic_t * <b>h</b> <i>first operand</i>
)
</pre>
<dd> Compute generic operation. Result accumulated
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiGeneric.c"TARGET="ABSTRACT"><CODE>ddiGeneric.c</CODE></A>

<dt><pre>
<A NAME="Ddi_GenericOp"></A>
Ddi_Generic_t * <I></I>
<B>Ddi_GenericOp</B>(
  Ddi_OpCode_e  <b>opcode</b>, <i>operation code</i>
  Ddi_Generic_t * <b>f</b>, <i>first operand</i>
  Ddi_Generic_t * <b>g</b>, <i>first operand</i>
  Ddi_Generic_t * <b>h</b> <i>first operand</i>
)
</pre>
<dd> Compute generic operation. Result generated
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiGeneric.c"TARGET="ABSTRACT"><CODE>ddiGeneric.c</CODE></A>

<dt><pre>
<A NAME="Ddi_GenericReadCode"></A>
Ddi_Code_e <I></I>
<B>Ddi_GenericReadCode</B>(
  Ddi_Generic_t * <b>f</b> <i></i>
)
</pre>
<dd> called through Ddi_ReadCode.
<p>

<dd> <b>Side Effects</b> Ddi_ReadCode
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiGeneric.c"TARGET="ABSTRACT"><CODE>ddiGeneric.c</CODE></A>

<dt><pre>
<A NAME="Ddi_GenericReadMgr"></A>
Ddi_Mgr_t * <I></I>
<B>Ddi_GenericReadMgr</B>(
  Ddi_Generic_t * <b>f</b> <i></i>
)
</pre>
<dd> called through Ddi_ReadMgr.
<p>

<dd> <b>Side Effects</b> Ddi_ReadMgr
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiGeneric.c"TARGET="ABSTRACT"><CODE>ddiGeneric.c</CODE></A>

<dt><pre>
<A NAME="Ddi_GenericReadName"></A>
char * <I></I>
<B>Ddi_GenericReadName</B>(
  Ddi_Generic_t * <b>f</b> <i></i>
)
</pre>
<dd> called through Ddi_ReadName.
<p>

<dd> <b>Side Effects</b> Ddi_ReadName
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiGeneric.c"TARGET="ABSTRACT"><CODE>ddiGeneric.c</CODE></A>

<dt><pre>
<A NAME="Ddi_GenericSetName"></A>
void <I></I>
<B>Ddi_GenericSetName</B>(
  Ddi_Generic_t * <b>f</b>, <i>block to be freed</i>
  char * <b>name</b> <i></i>
)
</pre>
<dd> Set name field of DDI node
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiGeneric.c"TARGET="ABSTRACT"><CODE>ddiGeneric.c</CODE></A>

<dt><pre>
<A NAME="Ddi_GenericUnlock"></A>
void <I></I>
<B>Ddi_GenericUnlock</B>(
  Ddi_Generic_t * <b>f</b> <i></i>
)
</pre>
<dd> Unlock DDI node so that can be freed again.
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_GenericLock">Ddi_GenericLock</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiGeneric.c"TARGET="ABSTRACT"><CODE>ddiGeneric.c</CODE></A>

<dt><pre>
<A NAME="Ddi_IthVar"></A>
Ddi_Var_t * <I></I>
<B>Ddi_IthVar</B>(
  Ddi_BddMgr * <b>ddm</b>, <i></i>
  int  <b>index</b> <i></i>
)
</pre>
<dd> Return the variable of a given index
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_VarIndex">Ddi_VarIndex</a>
<a href="#Ddi_VarAtLevel">Ddi_VarAtLevel</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiVar.c"TARGET="ABSTRACT"><CODE>ddiVar.c</CODE></A>

<dt><pre>
<A NAME="Ddi_MetaActive"></A>
int <I></I>
<B>Ddi_MetaActive</B>(
  Ddi_Mgr_t * <b>ddm</b> <i></i>
)
</pre>
<dd> Return true if Meta handling active (Ddi_MetaInit done)
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiMeta.c"TARGET="ABSTRACT"><CODE>ddiMeta.c</CODE></A>

<dt><pre>
<A NAME="Ddi_MetaInit"></A>
void <I></I>
<B>Ddi_MetaInit</B>(
  Ddi_Mgr_t * <b>ddm</b>, <i></i>
  Ddi_Meta_Method_e  <b>method</b>, <i></i>
  Ddi_Bdd_t * <b>ref</b>, <i></i>
  Ddi_Varset_t * <b>firstGroup</b>, <i></i>
  int  <b>sizeMin</b> <i></i>
)
</pre>
<dd> Initialize Meta BDD handling in DDI manager
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiMeta.c"TARGET="ABSTRACT"><CODE>ddiMeta.c</CODE></A>

<dt><pre>
<A NAME="Ddi_MetaQuit"></A>
void <I></I>
<B>Ddi_MetaQuit</B>(
  Ddi_Mgr_t * <b>ddm</b> <i></i>
)
</pre>
<dd> Close Meta BDD handling in DDI manager. This enables further
    opening of Meta BDD management with different method/parameters
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiMeta.c"TARGET="ABSTRACT"><CODE>ddiMeta.c</CODE></A>

<dt><pre>
<A NAME="Ddi_MgrAbortOnSiftDisable"></A>
void <I></I>
<B>Ddi_MgrAbortOnSiftDisable</B>(
  Ddi_Mgr_t * <b>dd</b> <i>dd manager</i>
)
</pre>
<dd> Disable Abort on sift.
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiMgr.c"TARGET="ABSTRACT"><CODE>ddiMgr.c</CODE></A>

<dt><pre>
<A NAME="Ddi_MgrAbortOnSiftEnable"></A>
void <I></I>
<B>Ddi_MgrAbortOnSiftEnable</B>(
  Ddi_Mgr_t * <b>dd</b> <i>dd manager</i>
)
</pre>
<dd> Enable Abort on sift.
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiMgr.c"TARGET="ABSTRACT"><CODE>ddiMgr.c</CODE></A>

<dt><pre>
<A NAME="Ddi_MgrAlign"></A>
void <I></I>
<B>Ddi_MgrAlign</B>(
  Ddi_Mgr_t * <b>dd</b>, <i>dd manager to be aligned</i>
  Ddi_Mgr_t * <b>ddRef</b> <i>reference dd manager</i>
)
</pre>
<dd> Aligns the order of two managers.
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiMgr.c"TARGET="ABSTRACT"><CODE>ddiMgr.c</CODE></A>

<dt><pre>
<A NAME="Ddi_MgrAutodynResume"></A>
void <I></I>
<B>Ddi_MgrAutodynResume</B>(
  Ddi_Mgr_t * <b>dd</b> <i>dd manager</i>
)
</pre>
<dd> Resume autodyn if suspended.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_MgrInit">Ddi_MgrInit</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiMgr.c"TARGET="ABSTRACT"><CODE>ddiMgr.c</CODE></A>

<dt><pre>
<A NAME="Ddi_MgrAutodynSuspend"></A>
void <I></I>
<B>Ddi_MgrAutodynSuspend</B>(
  Ddi_Mgr_t * <b>dd</b> <i>dd manager</i>
)
</pre>
<dd> Suspend autodyn if active.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_MgrInit">Ddi_MgrInit</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiMgr.c"TARGET="ABSTRACT"><CODE>ddiMgr.c</CODE></A>

<dt><pre>
<A NAME="Ddi_MgrCheckExtRef"></A>
int <I></I>
<B>Ddi_MgrCheckExtRef</B>(
  Ddi_Mgr_t * <b>ddm</b>, <i></i>
  int  <b>n</b> <i></i>
)
</pre>
<dd> Check number of externally referenced DDI handles.
    This is the numer of generic nodes (allocated - freed), diminished by
    the number of locked nodes + 3 (2 constants + variable array). 
    Return 0 upon failure.
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiMgr.c"TARGET="ABSTRACT"><CODE>ddiMgr.c</CODE></A>

<dt><pre>
<A NAME="Ddi_MgrConsistencyCheck"></A>
int <I></I>
<B>Ddi_MgrConsistencyCheck</B>(
  Ddi_Mgr_t * <b>ddm</b> <i></i>
)
</pre>
<dd> make checks on DDI manager. Return 0 for failure
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiMgr.c"TARGET="ABSTRACT"><CODE>ddiMgr.c</CODE></A>

<dt><pre>
<A NAME="Ddi_MgrCreateGroups2"></A>
void <I></I>
<B>Ddi_MgrCreateGroups2</B>(
  Ddi_Mgr_t * <b>dd</b>, <i>manager</i>
  Ddi_Vararray_t * <b>vfix</b>, <i>first array</i>
  Ddi_Vararray_t * <b>vmov</b> <i>first array</i>
)
</pre>
<dd> Create groups of 2 variables: variables of corresponding 
               indexes in vfix and vmov are coupled. If vmov[i
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiMgr.c"TARGET="ABSTRACT"><CODE>ddiMgr.c</CODE></A>

<dt><pre>
<A NAME="Ddi_MgrDup"></A>
Ddi_Mgr_t * <I></I>
<B>Ddi_MgrDup</B>(
  Ddi_Mgr_t * <b>dd</b> <i>source dd manager</i>
)
</pre>
<dd> Creates a copy of a DdManager.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_MgrQuit">Ddi_MgrQuit</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiMgr.c"TARGET="ABSTRACT"><CODE>ddiMgr.c</CODE></A>

<dt><pre>
<A NAME="Ddi_MgrInit"></A>
Ddi_Mgr_t * <I></I>
<B>Ddi_MgrInit</B>(
  char * <b>ddiName</b>, <i>Name of the DDI structure</i>
  DdManager * <b>CUMgr</b>, <i>Input CD manager. Created if NULL</i>
  unsigned int  <b>nvar</b>, <i>Initial Number of Variables</i>
  unsigned int  <b>numSlots</b>, <i>Initial Size of Unique Table</i>
  unsigned int  <b>cacheSize</b>, <i>Initial Size of Computed Table (cache)</i>
  unsigned long  <b>memorySizeMax</b> <i>Max size of Memory</i>
)
</pre>
<dd> Creates a DdManager.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_MgrQuit">Ddi_MgrQuit</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiMgr.c"TARGET="ABSTRACT"><CODE>ddiMgr.c</CODE></A>

<dt><pre>
<A NAME="Ddi_MgrOperation"></A>
int <I></I>
<B>Ddi_MgrOperation</B>(
  Ddi_Mgr_t ** <b>ddMgrP</b>, <i>DD Manager Pointer</i>
  char * <b>string</b>, <i>String</i>
  Pdtutil_MgrOp_t  <b>operationFlag</b>, <i>Operation Flag</i>
  void ** <b>voidPointer</b>, <i>Generic Pointer</i>
  Pdtutil_MgrRet_t * <b>returnFlagP</b> <i>Type of the Pointer Returned</i>
)
</pre>
<dd> 
<p>

<dd> <b>Side Effects</b> To be congruent operationFlag should be a Pdtutil_MgrOp_t
   type, and returnFlag of Pdtutil_MgrRet_t type.
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiMgr.c"TARGET="ABSTRACT"><CODE>ddiMgr.c</CODE></A>

<dt><pre>
<A NAME="Ddi_MgrOrdWrite"></A>
int <I></I>
<B>Ddi_MgrOrdWrite</B>(
  Ddi_Mgr_t * <b>dd</b>, <i>Decision Diagram Manager</i>
  char * <b>filename</b>, <i>File Name</i>
  FILE * <b>fp</b>, <i>Pointer to Store File</i>
  Pdtutil_VariableOrderFormat_e  <b>ordFileFormat</b> <i>File Format</i>
)
</pre>
<dd> This function stores the variable ordering of a dd manager.
    Variable names and aux ids are used.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiMgr.c"TARGET="ABSTRACT"><CODE>ddiMgr.c</CODE></A>

<dt><pre>
<A NAME="Ddi_MgrPeakProdLocalReset"></A>
void <I></I>
<B>Ddi_MgrPeakProdLocalReset</B>(
  Ddi_Mgr_t * <b>ddiMgr</b> <i>Decision Diagram Interface Manager</i>
)
</pre>
<dd> Reset peak product local
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiMgr.c"TARGET="ABSTRACT"><CODE>ddiMgr.c</CODE></A>

<dt><pre>
<A NAME="Ddi_MgrPeakProdUpdate"></A>
void <I></I>
<B>Ddi_MgrPeakProdUpdate</B>(
  Ddi_Mgr_t * <b>ddiMgr</b>, <i>Decision Diagram Interface Manager</i>
  int  <b>size</b> <i></i>
)
</pre>
<dd> Update peak product stats
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiMgr.c"TARGET="ABSTRACT"><CODE>ddiMgr.c</CODE></A>

<dt><pre>
<A NAME="Ddi_MgrPrintAllocStats"></A>
void <I></I>
<B>Ddi_MgrPrintAllocStats</B>(
  Ddi_Mgr_t * <b>ddm</b>, <i></i>
  FILE * <b>fp</b> <i></i>
)
</pre>
<dd> Print DDI manager allocation statistics
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiMgr.c"TARGET="ABSTRACT"><CODE>ddiMgr.c</CODE></A>

<dt><pre>
<A NAME="Ddi_MgrPrintExtRef"></A>
void <I></I>
<B>Ddi_MgrPrintExtRef</B>(
  Ddi_Mgr_t * <b>ddm</b>, <i></i>
  int  <b>minNodeId</b> <i></i>
)
</pre>
<dd> print ids of external refs
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiMgr.c"TARGET="ABSTRACT"><CODE>ddiMgr.c</CODE></A>

<dt><pre>
<A NAME="Ddi_MgrPrintStats"></A>
void <I></I>
<B>Ddi_MgrPrintStats</B>(
  Ddi_Mgr_t * <b>dd</b> <i>source dd manager</i>
)
</pre>
<dd> Prints on standard outputs statistics on a DD manager
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiMgr.c"TARGET="ABSTRACT"><CODE>ddiMgr.c</CODE></A>

<dt><pre>
<A NAME="Ddi_MgrQuit"></A>
void <I></I>
<B>Ddi_MgrQuit</B>(
  Ddi_Mgr_t * <b>dd</b> <i>dd manager</i>
)
</pre>
<dd> Close a DdManager.
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiMgr.c"TARGET="ABSTRACT"><CODE>ddiMgr.c</CODE></A>

<dt><pre>
<A NAME="Ddi_MgrReadCurrNodeId"></A>
int <I></I>
<B>Ddi_MgrReadCurrNodeId</B>(
  Ddi_Mgr_t * <b>dd</b> <i>source dd manager</i>
)
</pre>
<dd> Read current node id field. DDI nodes are identified by this
                id, which is incremented at any new node creation.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_MgrSetTracedId">Ddi_MgrSetTracedId</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiMgr.c"TARGET="ABSTRACT"><CODE>ddiMgr.c</CODE></A>

<dt><pre>
<A NAME="Ddi_MgrReadDynordThresh"></A>
unsigned int <I></I>
<B>Ddi_MgrReadDynordThresh</B>(
  Ddi_Mgr_t * <b>dd</b> <i>source dd manager</i>
)
</pre>
<dd> Returns the threshold for the next dynamic reordering.
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiMgr.c"TARGET="ABSTRACT"><CODE>ddiMgr.c</CODE></A>

<dt><pre>
<A NAME="Ddi_MgrReadExistClustThresh"></A>
int <I></I>
<B>Ddi_MgrReadExistClustThresh</B>(
  Ddi_Mgr_t * <b>dd</b> <i>source dd manager</i>
)
</pre>
<dd> Read part clustering threshold. This is the threshold used for
                quantification operators on partitioned BDDs.
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiMgr.c"TARGET="ABSTRACT"><CODE>ddiMgr.c</CODE></A>

<dt><pre>
<A NAME="Ddi_MgrReadExtBddRef"></A>
int <I></I>
<B>Ddi_MgrReadExtBddRef</B>(
  Ddi_Mgr_t * <b>dd</b> <i>source dd manager</i>
)
</pre>
<dd> Read the number of externally referenced BDD handles.
    This is the number of allocated - freed, diminished by
    the number of locked nodes.
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiMgr.c"TARGET="ABSTRACT"><CODE>ddiMgr.c</CODE></A>

<dt><pre>
<A NAME="Ddi_MgrReadExtBddarrayRef"></A>
int <I></I>
<B>Ddi_MgrReadExtBddarrayRef</B>(
  Ddi_Mgr_t * <b>dd</b> <i>source dd manager</i>
)
</pre>
<dd> Read the number of externally referenced BDD array handles.
    This is the number of allocated - freed, diminished by
    the number of locked nodes.
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiMgr.c"TARGET="ABSTRACT"><CODE>ddiMgr.c</CODE></A>

<dt><pre>
<A NAME="Ddi_MgrReadExtRef"></A>
int <I></I>
<B>Ddi_MgrReadExtRef</B>(
  Ddi_Mgr_t * <b>dd</b> <i>source dd manager</i>
)
</pre>
<dd> Read the number of externally referenced DDI handles.
    This is the numer of generic nodes (allocated - freed), diminished by
    the number of locked nodes + 3 (2 constants + variable array).
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiMgr.c"TARGET="ABSTRACT"><CODE>ddiMgr.c</CODE></A>

<dt><pre>
<A NAME="Ddi_MgrReadExtVarsetRef"></A>
int <I></I>
<B>Ddi_MgrReadExtVarsetRef</B>(
  Ddi_Mgr_t * <b>dd</b> <i>source dd manager</i>
)
</pre>
<dd> Read the number of externally referenced varset handles.
    This is the number of allocated - freed, diminished by
    the number of locked nodes.
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiMgr.c"TARGET="ABSTRACT"><CODE>ddiMgr.c</CODE></A>

<dt><pre>
<A NAME="Ddi_MgrReadMgrCU"></A>
DdManager * <I></I>
<B>Ddi_MgrReadMgrCU</B>(
  Ddi_Mgr_t * <b>dd</b> <i>source dd manager</i>
)
</pre>
<dd> Reads the Cudd Manager
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiMgr.c"TARGET="ABSTRACT"><CODE>ddiMgr.c</CODE></A>

<dt><pre>
<A NAME="Ddi_MgrReadOne"></A>
Ddi_Bdd_t * <I></I>
<B>Ddi_MgrReadOne</B>(
  Ddi_Mgr_t * <b>dd</b> <i>source dd manager</i>
)
</pre>
<dd> Reads one constant
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiMgr.c"TARGET="ABSTRACT"><CODE>ddiMgr.c</CODE></A>

<dt><pre>
<A NAME="Ddi_MgrReadOrdNamesAuxids"></A>
int <I></I>
<B>Ddi_MgrReadOrdNamesAuxids</B>(
  Ddi_Mgr_t * <b>dd</b>, <i>Manager</i>
  char * <b>filename</b>, <i>File Name</i>
  FILE * <b>fp</b>, <i>Pointer to the Store File</i>
  Pdtutil_VariableOrderFormat_e  <b>ordFileFormat</b> <i>File Format</i>
)
</pre>
<dd> This function reads the variable ordering of a dd manager.
    Existing variables with names in the ordering are shuffled
    to match the ordering.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiMgr.c"TARGET="ABSTRACT"><CODE>ddiMgr.c</CODE></A>

<dt><pre>
<A NAME="Ddi_MgrReadPeakProdGlobal"></A>
int <I></I>
<B>Ddi_MgrReadPeakProdGlobal</B>(
  Ddi_Mgr_t * <b>ddiMgr</b> <i>Decision Diagram Interface Manager</i>
)
</pre>
<dd> Read peak product global
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiMgr.c"TARGET="ABSTRACT"><CODE>ddiMgr.c</CODE></A>

<dt><pre>
<A NAME="Ddi_MgrReadPeakProdLocal"></A>
int <I></I>
<B>Ddi_MgrReadPeakProdLocal</B>(
  Ddi_Mgr_t * <b>ddiMgr</b> <i>Decision Diagram Interface Manager</i>
)
</pre>
<dd> Read peak product local
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiMgr.c"TARGET="ABSTRACT"><CODE>ddiMgr.c</CODE></A>

<dt><pre>
<A NAME="Ddi_MgrReadVarauxids"></A>
int * <I></I>
<B>Ddi_MgrReadVarauxids</B>(
  Ddi_Mgr_t * <b>dd</b> <i>source dd manager</i>
)
</pre>
<dd> Reads the variable auxiliary ids
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiMgr.c"TARGET="ABSTRACT"><CODE>ddiMgr.c</CODE></A>

<dt><pre>
<A NAME="Ddi_MgrReadVarnames"></A>
char** <I></I>
<B>Ddi_MgrReadVarnames</B>(
  Ddi_Mgr_t * <b>dd</b> <i>source dd manager</i>
)
</pre>
<dd> Reads the variable names
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiMgr.c"TARGET="ABSTRACT"><CODE>ddiMgr.c</CODE></A>

<dt><pre>
<A NAME="Ddi_MgrReadVerbosity"></A>
Pdtutil_VerbLevel_e <I></I>
<B>Ddi_MgrReadVerbosity</B>(
  Ddi_Mgr_t * <b>ddiMgr</b> <i>Decision Diagram Interface Manager</i>
)
</pre>
<dd> Read verbosity
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiMgr.c"TARGET="ABSTRACT"><CODE>ddiMgr.c</CODE></A>

<dt><pre>
<A NAME="Ddi_MgrReadZero"></A>
Ddi_Bdd_t * <I></I>
<B>Ddi_MgrReadZero</B>(
  Ddi_Mgr_t * <b>dd</b> <i>source dd manager</i>
)
</pre>
<dd> Reads zero constant
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiMgr.c"TARGET="ABSTRACT"><CODE>ddiMgr.c</CODE></A>

<dt><pre>
<A NAME="Ddi_MgrSetDynordThresh"></A>
void <I></I>
<B>Ddi_MgrSetDynordThresh</B>(
  Ddi_Mgr_t * <b>dd</b>, <i>source dd manager</i>
  unsigned int  <b>th</b> <i>threshold</i>
)
</pre>
<dd> Returns the threshold for the next dynamic reordering.
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiMgr.c"TARGET="ABSTRACT"><CODE>ddiMgr.c</CODE></A>

<dt><pre>
<A NAME="Ddi_MgrSetExistClustThresh"></A>
void <I></I>
<B>Ddi_MgrSetExistClustThresh</B>(
  Ddi_Mgr_t * <b>dd</b>, <i>source dd manager</i>
  int  <b>th</b> <i></i>
)
</pre>
<dd> Set part clustering threshold. This is the threshold used for
                quantification operators on partitioned BDDs.
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiMgr.c"TARGET="ABSTRACT"><CODE>ddiMgr.c</CODE></A>

<dt><pre>
<A NAME="Ddi_MgrSetMgrCU"></A>
void <I></I>
<B>Ddi_MgrSetMgrCU</B>(
  Ddi_Mgr_t * <b>dd</b>, <i>source dd manager</i>
  DdManager * <b>m</b> <i>CUDD manager</i>
)
</pre>
<dd> Sets the CUDD manager
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiMgr.c"TARGET="ABSTRACT"><CODE>ddiMgr.c</CODE></A>

<dt><pre>
<A NAME="Ddi_MgrSetOne"></A>
void <I></I>
<B>Ddi_MgrSetOne</B>(
  Ddi_Mgr_t * <b>dd</b>, <i>source dd manager</i>
  Ddi_Bdd_t * <b>one</b> <i>one constant</i>
)
</pre>
<dd> Sets the one constant
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiMgr.c"TARGET="ABSTRACT"><CODE>ddiMgr.c</CODE></A>

<dt><pre>
<A NAME="Ddi_MgrSetTracedId"></A>
void <I></I>
<B>Ddi_MgrSetTracedId</B>(
  Ddi_Mgr_t * <b>dd</b>, <i>source dd manager</i>
  int  <b>id</b> <i></i>
)
</pre>
<dd> Set traced node id field. Creation of node >= id are logged
                using DdiTraceNodeAlloc.
                This is expecially useful for debugging BDD leaks and memory
                bugs. To watch generation of node with given ID, put a 
                breakpoint on DdiTraceNodeAlloc after setting manager 
                tracedId to ID (Ddi_MgrSetTracedId(dd,ID)).
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_MgrReadCurrNodeId">Ddi_MgrReadCurrNodeId</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiMgr.c"TARGET="ABSTRACT"><CODE>ddiMgr.c</CODE></A>

<dt><pre>
<A NAME="Ddi_MgrSetVarauxids"></A>
void <I></I>
<B>Ddi_MgrSetVarauxids</B>(
  Ddi_Mgr_t * <b>dd</b>, <i>source dd manager</i>
  int * <b>va</b> <i>auxiliary variable ids</i>
)
</pre>
<dd> Sets the auxiliary variable ids
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiMgr.c"TARGET="ABSTRACT"><CODE>ddiMgr.c</CODE></A>

<dt><pre>
<A NAME="Ddi_MgrSetVarnames"></A>
void <I></I>
<B>Ddi_MgrSetVarnames</B>(
  Ddi_Mgr_t * <b>dd</b>, <i>source dd manager</i>
  char ** <b>vn</b> <i>names of variables</i>
)
</pre>
<dd> Sets the names of variables
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiMgr.c"TARGET="ABSTRACT"><CODE>ddiMgr.c</CODE></A>

<dt><pre>
<A NAME="Ddi_MgrSetVerbosity"></A>
void <I></I>
<B>Ddi_MgrSetVerbosity</B>(
  Ddi_Mgr_t * <b>ddiMgr</b>, <i>Decision Diagram Interface Manager</i>
  Pdtutil_VerbLevel_e  <b>verbosity</b> <i>Verbosity Level</i>
)
</pre>
<dd> Set verbosity
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiMgr.c"TARGET="ABSTRACT"><CODE>ddiMgr.c</CODE></A>

<dt><pre>
<A NAME="Ddi_MgrSetZero"></A>
void <I></I>
<B>Ddi_MgrSetZero</B>(
  Ddi_Mgr_t * <b>dd</b>, <i>source dd manager</i>
  Ddi_Bdd_t * <b>zero</b> <i>zero constant</i>
)
</pre>
<dd> Sets the zero constant
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiMgr.c"TARGET="ABSTRACT"><CODE>ddiMgr.c</CODE></A>

<dt><pre>
<A NAME="Ddi_MgrShuffle"></A>
void <I></I>
<B>Ddi_MgrShuffle</B>(
  Ddi_Mgr_t * <b>dd</b>, <i>dd Manager to be Alligned</i>
  int * <b>sortedIds</b>, <i>Array of sorted ids</i>
  int  <b>nids</b> <i>Number of ids</i>
)
</pre>
<dd> Reorders all DDs in a manager according to the input
    order. The input specification may be partial, i.e.
    it may include only a subset of variables.
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiMgr.c"TARGET="ABSTRACT"><CODE>ddiMgr.c</CODE></A>

<dt><pre>
<A NAME="Ddi_MgrUpdate"></A>
void <I></I>
<B>Ddi_MgrUpdate</B>(
  Ddi_Mgr_t * <b>ddm</b> <i></i>
)
</pre>
<dd> update DDI manager after directly working on CUDD manager.
    New variables have possibly been created.
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiMgr.c"TARGET="ABSTRACT"><CODE>ddiMgr.c</CODE></A>

<dt><pre>
<A NAME="Ddi_PrintCuddVersion"></A>
void <I></I>
<B>Ddi_PrintCuddVersion</B>(
  FILE * <b>fp</b> <i></i>
)
</pre>
<dd> Returns the version of CUDD package
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiUtil.c"TARGET="ABSTRACT"><CODE>ddiUtil.c</CODE></A>

<dt><pre>
<A NAME="Ddi_PrintDdArray"></A>
void <I></I>
<B>Ddi_PrintDdArray</B>(
  Ddi_Bddarray_t * <b>array</b> <i></i>
)
</pre>
<dd> Prints the size of each function in a DdArray
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_PrintVararray">Ddi_PrintVararray</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiNew.c"TARGET="ABSTRACT"><CODE>ddiNew.c</CODE></A>

<dt><pre>
<A NAME="Ddi_PrintVararray"></A>
void <I></I>
<B>Ddi_PrintVararray</B>(
  Ddi_Vararray_t * <b>array</b> <i></i>
)
</pre>
<dd> Prints the indices of a Vararray
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_PrintDdArray">Ddi_PrintDdArray</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiNew.c"TARGET="ABSTRACT"><CODE>ddiNew.c</CODE></A>

<dt><pre>
<A NAME="Ddi_ProfileHeuristicEnum2String"></A>
char * <I></I>
<B>Ddi_ProfileHeuristicEnum2String</B>(
  Cuplus_PruneHeuristic_e  <b>enumType</b> <i></i>
)
</pre>
<dd> Given an Enumerated type Returns a string
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiUtil.c"TARGET="ABSTRACT"><CODE>ddiUtil.c</CODE></A>

<dt><pre>
<A NAME="Ddi_ProfileHeuristicString2Enum"></A>
Cuplus_PruneHeuristic_e <I></I>
<B>Ddi_ProfileHeuristicString2Enum</B>(
  char * <b>string</b> <i>String to Analyze</i>
)
</pre>
<dd> It receives a string; to facilitate the user that string
    can be an easy-to-remember predefined code or an integer number
    (interpreted as a string).
    It returns the dense method type.
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiUtil.c"TARGET="ABSTRACT"><CODE>ddiUtil.c</CODE></A>

<dt><pre>
<A NAME="Ddi_ReadCacheHits"></A>
double <I></I>
<B>Ddi_ReadCacheHits</B>(
  Ddi_Mgr_t * <b>dd</b> <i>dd manager</i>
)
</pre>
<dd> Returns the number of cache hits.
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiMgr.c"TARGET="ABSTRACT"><CODE>ddiMgr.c</CODE></A>

<dt><pre>
<A NAME="Ddi_ReadCacheLookUps"></A>
double <I></I>
<B>Ddi_ReadCacheLookUps</B>(
  Ddi_Mgr_t * <b>dd</b> <i>dd manager</i>
)
</pre>
<dd> Returns the number of cache look-ups.
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiMgr.c"TARGET="ABSTRACT"><CODE>ddiMgr.c</CODE></A>

<dt><pre>
<A NAME="Ddi_ReadCacheSlots"></A>
unsigned int <I></I>
<B>Ddi_ReadCacheSlots</B>(
  Ddi_Mgr_t * <b>dd</b> <i>source dd manager</i>
)
</pre>
<dd> Reads the number of slots in the cache.
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiMgr.c"TARGET="ABSTRACT"><CODE>ddiMgr.c</CODE></A>

<dt><pre>
<A NAME="Ddi_ReadCube"></A>
Ddi_Bdd_t * <I></I>
<B>Ddi_ReadCube</B>(
  Ddi_Mgr_t * <b>dd</b>, <i></i>
  FILE * <b>fp</b>, <i></i>
  int  <b>idOrName</b> <i></i>
)
</pre>
<dd> The user can make a cube typing the index of variables
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiNew.c"TARGET="ABSTRACT"><CODE>ddiNew.c</CODE></A>

<dt><pre>
<A NAME="Ddi_ReadDdiName"></A>
char * <I></I>
<B>Ddi_ReadDdiName</B>(
  Ddi_Mgr_t * <b>dd</b> <i>source dd manager</i>
)
</pre>
<dd> Returns the threshold for the next dynamic reordering.
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiMgr.c"TARGET="ABSTRACT"><CODE>ddiMgr.c</CODE></A>

<dt><pre>
<A NAME="Ddi_ReadMaxCacheHard"></A>
unsigned int <I></I>
<B>Ddi_ReadMaxCacheHard</B>(
  Ddi_Mgr_t * <b>dd</b> <i>dd manager</i>
)
</pre>
<dd> Reads the maxCacheHard parameter of the manager.
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiMgr.c"TARGET="ABSTRACT"><CODE>ddiMgr.c</CODE></A>

<dt><pre>
<A NAME="Ddi_ReadMaxCache"></A>
unsigned int <I></I>
<B>Ddi_ReadMaxCache</B>(
  Ddi_Mgr_t* <b>dd</b> <i>dd manager</i>
)
</pre>
<dd> Returns the soft limit for the cache size.
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiMgr.c"TARGET="ABSTRACT"><CODE>ddiMgr.c</CODE></A>

<dt><pre>
<A NAME="Ddi_ReadMinHit"></A>
unsigned int <I></I>
<B>Ddi_ReadMinHit</B>(
  Ddi_Mgr_t * <b>dd</b> <i>dd manager</i>
)
</pre>
<dd> Reads the hit ratio that causes resizing of the computed
  table.
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiMgr.c"TARGET="ABSTRACT"><CODE>ddiMgr.c</CODE></A>

<dt><pre>
<A NAME="Ddi_ReadVarset"></A>
Ddi_Varset_t * <I></I>
<B>Ddi_ReadVarset</B>(
  Ddi_Mgr_t * <b>dd</b>, <i></i>
  FILE * <b>fp</b>, <i></i>
  int  <b>idOrName</b> <i></i>
)
</pre>
<dd> The user can make a cube typing the index of variables
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiNew.c"TARGET="ABSTRACT"><CODE>ddiNew.c</CODE></A>

<dt><pre>
<A NAME="Ddi_ReorderingMethodEnum2String"></A>
char * <I></I>
<B>Ddi_ReorderingMethodEnum2String</B>(
  Cudd_ReorderingType  <b>enumType</b> <i></i>
)
</pre>
<dd> Given an Enumerated type Returns a string
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiUtil.c"TARGET="ABSTRACT"><CODE>ddiUtil.c</CODE></A>

<dt><pre>
<A NAME="Ddi_ReorderingMethodString2Enum"></A>
Cudd_ReorderingType <I></I>
<B>Ddi_ReorderingMethodString2Enum</B>(
  char * <b>string</b> <i>String to Analyze</i>
)
</pre>
<dd> It receives a string; to facilitate the user that string
    can be an easy-to-remember predefined code or an integer number
    (interpreted as a string).
    It returns the dense method type.
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiUtil.c"TARGET="ABSTRACT"><CODE>ddiUtil.c</CODE></A>

<dt><pre>
<A NAME="Ddi_SetDdiName"></A>
void <I></I>
<B>Ddi_SetDdiName</B>(
  Ddi_Mgr_t * <b>dd</b>, <i>source dd manager</i>
  char * <b>ddiName</b> <i></i>
)
</pre>
<dd> Returns the threshold for the next dynamic reordering.
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiMgr.c"TARGET="ABSTRACT"><CODE>ddiMgr.c</CODE></A>

<dt><pre>
<A NAME="Ddi_VarAtLevel"></A>
Ddi_Var_t * <I></I>
<B>Ddi_VarAtLevel</B>(
  Ddi_BddMgr * <b>ddm</b>, <i></i>
  int  <b>lev</b> <i></i>
)
</pre>
<dd> Return variable at a given level in the order
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_IthVar">Ddi_IthVar</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiVar.c"TARGET="ABSTRACT"><CODE>ddiVar.c</CODE></A>

<dt><pre>
<A NAME="Ddi_VarAttachAuxid"></A>
void <I></I>
<B>Ddi_VarAttachAuxid</B>(
  Ddi_Var_t * <b>var</b>, <i></i>
  int  <b>auxid</b> <i></i>
)
</pre>
<dd> Set the variable auxid of a variable
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiVar.c"TARGET="ABSTRACT"><CODE>ddiVar.c</CODE></A>

<dt><pre>
<A NAME="Ddi_VarAttachName"></A>
void <I></I>
<B>Ddi_VarAttachName</B>(
  Ddi_Var_t * <b>var</b>, <i></i>
  char * <b>name</b> <i></i>
)
</pre>
<dd> Attach a given name to the variable
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_VarDetachName">Ddi_VarDetachName</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiVar.c"TARGET="ABSTRACT"><CODE>ddiVar.c</CODE></A>

<dt><pre>
<A NAME="Ddi_VarAuxid"></A>
int <I></I>
<B>Ddi_VarAuxid</B>(
  Ddi_Var_t * <b>var</b> <i></i>
)
</pre>
<dd> Return the variable auxid (-1 if auxids not defined)
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_VarName">Ddi_VarName</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiVar.c"TARGET="ABSTRACT"><CODE>ddiVar.c</CODE></A>

<dt><pre>
<A NAME="Ddi_VarCopy"></A>
Ddi_Var_t * <I></I>
<B>Ddi_VarCopy</B>(
  Ddi_BddMgr * <b>dd2</b>, <i>destination manager</i>
  Ddi_Var_t * <b>v</b> <i>variable to be copied</i>
)
</pre>
<dd> Find the variable corresponding to v in the destination
               manager. Variable correspondence is for now limited to
               index matching.
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiVar.c"TARGET="ABSTRACT"><CODE>ddiVar.c</CODE></A>

<dt><pre>
<A NAME="Ddi_VarCurrPos"></A>
int <I></I>
<B>Ddi_VarCurrPos</B>(
  Ddi_Var_t * <b>var</b> <i></i>
)
</pre>
<dd> Return current position of var in variable order
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiVar.c"TARGET="ABSTRACT"><CODE>ddiVar.c</CODE></A>

<dt><pre>
<A NAME="Ddi_VarDetachName"></A>
void <I></I>
<B>Ddi_VarDetachName</B>(
  Ddi_Var_t * <b>var</b> <i></i>
)
</pre>
<dd> Clear the name of a variable
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_VarAttachName">Ddi_VarAttachName</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiVar.c"TARGET="ABSTRACT"><CODE>ddiVar.c</CODE></A>

<dt><pre>
<A NAME="Ddi_VarFromAuxid"></A>
Ddi_Var_t * <I></I>
<B>Ddi_VarFromAuxid</B>(
  Ddi_BddMgr * <b>ddm</b>, <i></i>
  int  <b>auxid</b> <i></i>
)
</pre>
<dd> Still a linear search !
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_VArFromName">Ddi_VArFromName</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiVar.c"TARGET="ABSTRACT"><CODE>ddiVar.c</CODE></A>

<dt><pre>
<A NAME="Ddi_VarFromCU"></A>
Ddi_Var_t * <I></I>
<B>Ddi_VarFromCU</B>(
  Ddi_BddMgr * <b>ddm</b>, <i></i>
  DdNode * <b>v</b> <i></i>
)
</pre>
<dd> Convert a CUDD variable to a DDI variable
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiVar.c"TARGET="ABSTRACT"><CODE>ddiVar.c</CODE></A>

<dt><pre>
<A NAME="Ddi_VarFromName"></A>
Ddi_Var_t * <I></I>
<B>Ddi_VarFromName</B>(
  Ddi_BddMgr * <b>ddm</b>, <i></i>
  char * <b>name</b> <i></i>
)
</pre>
<dd> Still a linear search !
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_VarFromAuxid">Ddi_VarFromAuxid</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiVar.c"TARGET="ABSTRACT"><CODE>ddiVar.c</CODE></A>

<dt><pre>
<A NAME="Ddi_VarInVarset"></A>
int <I></I>
<B>Ddi_VarInVarset</B>(
  Ddi_Varset_t * <b>varset</b>, <i>var-set</i>
  Ddi_Var_t * <b>var</b> <i>variable</i>
)
</pre>
<dd> Return true (non 0) if var is in varset
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiVarset.c"TARGET="ABSTRACT"><CODE>ddiVarset.c</CODE></A>

<dt><pre>
<A NAME="Ddi_VarIndex"></A>
int <I></I>
<B>Ddi_VarIndex</B>(
  Ddi_Var_t * <b>var</b> <i></i>
)
</pre>
<dd> Return the variable index (CUDD variable index)
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_IthVar">Ddi_IthVar</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiVar.c"TARGET="ABSTRACT"><CODE>ddiVar.c</CODE></A>

<dt><pre>
<A NAME="Ddi_VarIsGrouped"></A>
int <I></I>
<B>Ddi_VarIsGrouped</B>(
  Ddi_Var_t * <b>v</b> <i></i>
)
</pre>
<dd> Return true (non 0) if variable is in variable group
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiVar.c"TARGET="ABSTRACT"><CODE>ddiVar.c</CODE></A>

<dt><pre>
<A NAME="Ddi_VarMakeGroupFixed"></A>
void <I></I>
<B>Ddi_VarMakeGroupFixed</B>(
  Ddi_BddMgr * <b>dd</b>, <i></i>
  Ddi_Var_t * <b>v</b>, <i></i>
  int  <b>grpSize</b> <i></i>
)
</pre>
<dd> Same as Ddi_VarMakeGroup but no dynamic reordering allowed
               within group
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_VarMakeGroupFixed">Ddi_VarMakeGroupFixed</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiVar.c"TARGET="ABSTRACT"><CODE>ddiVar.c</CODE></A>

<dt><pre>
<A NAME="Ddi_VarMakeGroup"></A>
void <I></I>
<B>Ddi_VarMakeGroup</B>(
  Ddi_BddMgr * <b>dd</b>, <i></i>
  Ddi_Var_t * <b>v</b>, <i></i>
  int  <b>grpSize</b> <i></i>
)
</pre>
<dd> A group of variables is created for group sifting. 
               The group starts at v and contains grpSize variables
               (following v in the ordering. Sifting is allowed within the
               group
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_VarMakeGroupFixed">Ddi_VarMakeGroupFixed</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiVar.c"TARGET="ABSTRACT"><CODE>ddiVar.c</CODE></A>

<dt><pre>
<A NAME="Ddi_VarName"></A>
char * <I></I>
<B>Ddi_VarName</B>(
  Ddi_Var_t * <b>var</b> <i></i>
)
</pre>
<dd> Return the name of a variable
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiVar.c"TARGET="ABSTRACT"><CODE>ddiVar.c</CODE></A>

<dt><pre>
<A NAME="Ddi_VarNewAfterVar"></A>
Ddi_Var_t * <I></I>
<B>Ddi_VarNewAfterVar</B>(
  Ddi_Var_t * <b>var</b> <i></i>
)
</pre>
<dd> Create a new variable after (in the variable order)
    the given variable.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_NewVarAtLevel">Ddi_NewVarAtLevel</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiVar.c"TARGET="ABSTRACT"><CODE>ddiVar.c</CODE></A>

<dt><pre>
<A NAME="Ddi_VarNewAtLevel"></A>
Ddi_Var_t * <I></I>
<B>Ddi_VarNewAtLevel</B>(
  Ddi_BddMgr * <b>ddm</b>, <i></i>
  int  <b>lev</b> <i></i>
)
</pre>
<dd> Returns a new variable at a given level in the order
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_VarNew">Ddi_VarNew</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiVar.c"TARGET="ABSTRACT"><CODE>ddiVar.c</CODE></A>

<dt><pre>
<A NAME="Ddi_VarNewBeforeVar"></A>
Ddi_Var_t * <I></I>
<B>Ddi_VarNewBeforeVar</B>(
  Ddi_Var_t * <b>var</b> <i></i>
)
</pre>
<dd> Create a new variable before (in the variable order)
    the given variable.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_NewVarAtLevel">Ddi_NewVarAtLevel</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiVar.c"TARGET="ABSTRACT"><CODE>ddiVar.c</CODE></A>

<dt><pre>
<A NAME="Ddi_VarNew"></A>
Ddi_Var_t * <I></I>
<B>Ddi_VarNew</B>(
  Ddi_BddMgr * <b>ddm</b> <i></i>
)
</pre>
<dd> Create a new variable (generated within a CUDD manager)
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_VarNewAtLevel">Ddi_VarNewAtLevel</a>
<a href="#Ddi_VarFromCU">Ddi_VarFromCU</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiVar.c"TARGET="ABSTRACT"><CODE>ddiVar.c</CODE></A>

<dt><pre>
<A NAME="Ddi_VarReadGroup"></A>
Ddi_Varset_t * <I></I>
<B>Ddi_VarReadGroup</B>(
  Ddi_Var_t * <b>v</b> <i></i>
)
</pre>
<dd> Return variable group including v. NULL if v is not in a group
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiVar.c"TARGET="ABSTRACT"><CODE>ddiVar.c</CODE></A>

<dt><pre>
<A NAME="Ddi_VarSubst"></A>
Ddi_Bdd_t * <I></I>
<B>Ddi_VarSubst</B>(
  Ddi_Bdd_t * <b>f</b>, <i>BDD</i>
  Ddi_Vararray_t * <b>x</b>, <i>first array of variables</i>
  Ddi_Vararray_t * <b>y</b> <i>second array of variables</i>
)
</pre>
<dd> The function returns the pointer to a new function with the
              variables swapped (x replace y), or NULL otherwise.
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiNew.c"TARGET="ABSTRACT"><CODE>ddiNew.c</CODE></A>

<dt><pre>
<A NAME="Ddi_VarToCU"></A>
DdNode * <I></I>
<B>Ddi_VarToCU</B>(
  Ddi_Var_t * <b>v</b> <i></i>
)
</pre>
<dd> Return the CUDD bdd node of a variable
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiVar.c"TARGET="ABSTRACT"><CODE>ddiVar.c</CODE></A>

<dt><pre>
<A NAME="Ddi_VararrayAlloc"></A>
Ddi_Vararray_t * <I></I>
<B>Ddi_VararrayAlloc</B>(
  Ddi_Mgr_t * <b>mgr</b>, <i>DDI manager</i>
  int  <b>size</b> <i>array length</i>
)
</pre>
<dd> Allocate a new array of variables of given length
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiVararray.c"TARGET="ABSTRACT"><CODE>ddiVararray.c</CODE></A>

<dt><pre>
<A NAME="Ddi_VararrayAppend"></A>
void <I></I>
<B>Ddi_VararrayAppend</B>(
  Ddi_Vararray_t * <b>array1</b>, <i>first array</i>
  Ddi_Vararray_t * <b>array2</b> <i>array to be appended</i>
)
</pre>
<dd> Append the elements of array2 at the end of array1
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_VararrayJoin">Ddi_VararrayJoin</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiVararray.c"TARGET="ABSTRACT"><CODE>ddiVararray.c</CODE></A>

<dt><pre>
<A NAME="Ddi_VararrayClear"></A>
void <I></I>
<B>Ddi_VararrayClear</B>(
  Ddi_Vararray_t * <b>array</b>, <i>array of variables</i>
  int  <b>pos</b> <i>position of element to be cleared</i>
)
</pre>
<dd> clear array at given position (variable is replaced by NULL)
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_VararrayRead">Ddi_VararrayRead</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiVararray.c"TARGET="ABSTRACT"><CODE>ddiVararray.c</CODE></A>

<dt><pre>
<A NAME="Ddi_VararrayCopy"></A>
Ddi_Vararray_t * <I></I>
<B>Ddi_VararrayCopy</B>(
  Ddi_BddMgr * <b>ddm</b>, <i>dd Manager</i>
  Ddi_Vararray_t * <b>old</b> <i>array of variables</i>
)
</pre>
<dd> Variable correspondence is established "by index", i.e. 
               variables with same index in different manager correspond
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_VararrayDup">Ddi_VararrayDup</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiVararray.c"TARGET="ABSTRACT"><CODE>ddiVararray.c</CODE></A>

<dt><pre>
<A NAME="Ddi_VararrayDup"></A>
Ddi_Vararray_t * <I></I>
<B>Ddi_VararrayDup</B>(
  Ddi_Vararray_t * <b>old</b> <i>array to be duplicated</i>
)
</pre>
<dd> Only the "array" part is duplicated. Variables are never 
               duplicated nor freed, except when closing the owner manager
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_VararrayAlloc">Ddi_VararrayAlloc</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiVararray.c"TARGET="ABSTRACT"><CODE>ddiVararray.c</CODE></A>

<dt><pre>
<A NAME="Ddi_VararrayExtract"></A>
Ddi_Var_t * <I></I>
<B>Ddi_VararrayExtract</B>(
  Ddi_Vararray_t * <b>array</b>, <i>variable array</i>
  int  <b>i</b> <i>position</i>
)
</pre>
<dd> Extract the variable at i-th position in array. 
    The extracted variable is removed from the array and the following entries
    are shifted up.
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_VararrayInsert">Ddi_VararrayInsert</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiVararray.c"TARGET="ABSTRACT"><CODE>ddiVararray.c</CODE></A>

<dt><pre>
<A NAME="Ddi_VararrayInsertLast"></A>
void <I></I>
<B>Ddi_VararrayInsertLast</B>(
  Ddi_Vararray_t * <b>array</b>, <i>array of variables</i>
  Ddi_Var_t * <b>v</b> <i>variable to be written</i>
)
</pre>
<dd> Insert a variable in array at last (new) position
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_VararrayExtract">Ddi_VararrayExtract</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiVararray.c"TARGET="ABSTRACT"><CODE>ddiVararray.c</CODE></A>

<dt><pre>
<A NAME="Ddi_VararrayInsert"></A>
void <I></I>
<B>Ddi_VararrayInsert</B>(
  Ddi_Vararray_t * <b>array</b>, <i>array of variables</i>
  int  <b>pos</b>, <i>position of new element</i>
  Ddi_Var_t * <b>v</b> <i>variable to be written</i>
)
</pre>
<dd> Insert a variable in array at given position. 
    Following entries are shifted down.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_VararrayExtract">Ddi_VararrayExtract</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiVararray.c"TARGET="ABSTRACT"><CODE>ddiVararray.c</CODE></A>

<dt><pre>
<A NAME="Ddi_VararrayMakeFromCU"></A>
Ddi_Vararray_t * <I></I>
<B>Ddi_VararrayMakeFromCU</B>(
  Ddi_Mgr_t * <b>mgr</b>, <i></i>
  DdNode ** <b>array</b>, <i></i>
  int  <b>n</b> <i></i>
)
</pre>
<dd> No variable dup is done (as all DDI operations working with
               variables)
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_VararrayToCU">Ddi_VararrayToCU</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiVararray.c"TARGET="ABSTRACT"><CODE>ddiVararray.c</CODE></A>

<dt><pre>
<A NAME="Ddi_VararrayMakeFromInt"></A>
Ddi_Vararray_t * <I></I>
<B>Ddi_VararrayMakeFromInt</B>(
  Ddi_Mgr_t * <b>mgr</b>, <i></i>
  int * <b>array</b>, <i></i>
  int  <b>n</b> <i></i>
)
</pre>
<dd> Integer indexes are used as CUDD indexes.
               No variable dup is done (as all DDI operations working with
               variables)
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_VararrayToCU">Ddi_VararrayToCU</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiVararray.c"TARGET="ABSTRACT"><CODE>ddiVararray.c</CODE></A>

<dt><pre>
<A NAME="Ddi_VararrayNum"></A>
int <I></I>
<B>Ddi_VararrayNum</B>(
  Ddi_Vararray_t * <b>array</b> <i></i>
)
</pre>
<dd> Return the number of variables (entries) in array
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiVararray.c"TARGET="ABSTRACT"><CODE>ddiVararray.c</CODE></A>

<dt><pre>
<A NAME="Ddi_VararrayRead"></A>
Ddi_Var_t * <I></I>
<B>Ddi_VararrayRead</B>(
  Ddi_Vararray_t * <b>array</b>, <i>variable array</i>
  int  <b>i</b> <i>position</i>
)
</pre>
<dd> Return the variable at i-th position in array
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_VararrayInsert">Ddi_VararrayInsert</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiVararray.c"TARGET="ABSTRACT"><CODE>ddiVararray.c</CODE></A>

<dt><pre>
<A NAME="Ddi_VararrayRemove"></A>
void <I></I>
<B>Ddi_VararrayRemove</B>(
  Ddi_Vararray_t * <b>array</b>, <i>array of variables</i>
  int  <b>pos</b> <i>position of element to be cleared</i>
)
</pre>
<dd> Remove array entry at given position.
    This operation is equivalent to extract (but return type is void).
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_VararrayExtract">Ddi_VararrayExtract</a>
<a href="#Ddi_VararrayClear">Ddi_VararrayClear</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiVararray.c"TARGET="ABSTRACT"><CODE>ddiVararray.c</CODE></A>

<dt><pre>
<A NAME="Ddi_VararrayToCU"></A>
DdNode ** <I></I>
<B>Ddi_VararrayToCU</B>(
  Ddi_Vararray_t * <b>array</b> <i></i>
)
</pre>
<dd> Generate a dynamic allocated array of pointers to CUDD BDDs 
              representing variables in input array.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_VararrayMakeFromCU">Ddi_VararrayMakeFromCU</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiVararray.c"TARGET="ABSTRACT"><CODE>ddiVararray.c</CODE></A>

<dt><pre>
<A NAME="Ddi_VararrayToInt"></A>
int * <I>array of integer</I>
<B>Ddi_VararrayToInt</B>(
  Ddi_Vararray_t * <b>array</b> <i>array of variables</i>
)
</pre>
<dd> Generate a dynamically allocated array of integer variable 
    indexes. Integer indexes are taken from CUDD indexes.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_VararrayToCU">Ddi_VararrayToCU</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiVararray.c"TARGET="ABSTRACT"><CODE>ddiVararray.c</CODE></A>

<dt><pre>
<A NAME="Ddi_VararrayWrite"></A>
void <I></I>
<B>Ddi_VararrayWrite</B>(
  Ddi_Vararray_t * <b>array</b>, <i>array of variables</i>
  int  <b>pos</b>, <i>position of new element</i>
  Ddi_Var_t * <b>var</b> <i>variable to be inserted</i>
)
</pre>
<dd> Write a variable in array at given position
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_VararrayRead">Ddi_VararrayRead</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiVararray.c"TARGET="ABSTRACT"><CODE>ddiVararray.c</CODE></A>

<dt><pre>
<A NAME="Ddi_VarsetAddAcc"></A>
Ddi_Varset_t * <I></I>
<B>Ddi_VarsetAddAcc</B>(
  Ddi_Varset_t * <b>vs</b>, <i>var-set</i>
  Ddi_Var_t * <b>v</b> <i>the new variable added to var-set</i>
)
</pre>
<dd> Add variable to var-set. Result is accumulated
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_VarsetAdd">Ddi_VarsetAdd</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiVarset.c"TARGET="ABSTRACT"><CODE>ddiVarset.c</CODE></A>

<dt><pre>
<A NAME="Ddi_VarsetAdd"></A>
Ddi_Varset_t * <I></I>
<B>Ddi_VarsetAdd</B>(
  Ddi_Varset_t * <b>vs</b>, <i>var-set</i>
  Ddi_Var_t * <b>v</b> <i>the new variable added to var-set</i>
)
</pre>
<dd> Add variable to var-set. Result is generated
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_VarsetAddAcc">Ddi_VarsetAddAcc</a>
<a href="#Ddi_VarsetRemove">Ddi_VarsetRemove</a>
<a href="#Ddi_VarsetRemoveAcc">Ddi_VarsetRemoveAcc</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiVarset.c"TARGET="ABSTRACT"><CODE>ddiVarset.c</CODE></A>

<dt><pre>
<A NAME="Ddi_VarsetBottom"></A>
Ddi_Var_t * <I></I>
<B>Ddi_VarsetBottom</B>(
  Ddi_Varset_t * <b>varset</b> <i>var-set</i>
)
</pre>
<dd> Return the bottom variable in the ordering
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_VarsetTop">Ddi_VarsetTop</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiVarset.c"TARGET="ABSTRACT"><CODE>ddiVarset.c</CODE></A>

<dt><pre>
<A NAME="Ddi_VarsetCopy"></A>
Ddi_Varset_t * <I></I>
<B>Ddi_VarsetCopy</B>(
  Ddi_BddMgr * <b>dd2</b>, <i>destination manager</i>
  Ddi_Varset_t * <b>src</b> <i>var-set to be copied</i>
)
</pre>
<dd> Copy a var-set to another manager
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiVarset.c"TARGET="ABSTRACT"><CODE>ddiVarset.c</CODE></A>

<dt><pre>
<A NAME="Ddi_VarsetDiffAcc"></A>
Ddi_Varset_t * <I></I>
<B>Ddi_VarsetDiffAcc</B>(
  Ddi_Varset_t * <b>v1</b>, <i>first var-set</i>
  Ddi_Varset_t * <b>v2</b> <i>second var-set</i>
)
</pre>
<dd> Return difference of two var-sets. Result accumulated
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_VarsetUnion">Ddi_VarsetUnion</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiVarset.c"TARGET="ABSTRACT"><CODE>ddiVarset.c</CODE></A>

<dt><pre>
<A NAME="Ddi_VarsetDiff"></A>
Ddi_Varset_t * <I></I>
<B>Ddi_VarsetDiff</B>(
  Ddi_Varset_t * <b>v1</b>, <i>first var-set</i>
  Ddi_Varset_t * <b>v2</b> <i>second var-set</i>
)
</pre>
<dd> Return difference of two var-sets. Result generated
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_VarsetUnionAcc">Ddi_VarsetUnionAcc</a>
<a href="#Ddi_VarsetIntersect">Ddi_VarsetIntersect</a>
<a href="#Ddi_VarsetDiff">Ddi_VarsetDiff</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiVarset.c"TARGET="ABSTRACT"><CODE>ddiVarset.c</CODE></A>

<dt><pre>
<A NAME="Ddi_VarsetDup"></A>
Ddi_Varset_t * <I></I>
<B>Ddi_VarsetDup</B>(
  Ddi_Varset_t * <b>src</b> <i>var-set to be copied</i>
)
</pre>
<dd> Duplicate a var-set
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiVarset.c"TARGET="ABSTRACT"><CODE>ddiVarset.c</CODE></A>

<dt><pre>
<A NAME="Ddi_VarsetEqual"></A>
int <I></I>
<B>Ddi_VarsetEqual</B>(
  Ddi_Varset_t * <b>varset1</b>, <i>first var-set</i>
  Ddi_Varset_t * <b>varset2</b> <i>second var-set</i>
)
</pre>
<dd> Return true (non 0) if the two var-sets are equal
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiVarset.c"TARGET="ABSTRACT"><CODE>ddiVarset.c</CODE></A>

<dt><pre>
<A NAME="Ddi_VarsetEvalFree"></A>
Ddi_Varset_t * <I></I>
<B>Ddi_VarsetEvalFree</B>(
  Ddi_Varset_t * <b>f</b>, <i>expression</i>
  Ddi_Varset_t * <b>g</b> <i>varset to be freed</i>
)
</pre>
<dd> Evaluates an expression and frees first argument
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiVarset.c"TARGET="ABSTRACT"><CODE>ddiVarset.c</CODE></A>

<dt><pre>
<A NAME="Ddi_VarsetIntersectAcc"></A>
Ddi_Varset_t * <I></I>
<B>Ddi_VarsetIntersectAcc</B>(
  Ddi_Varset_t * <b>v1</b>, <i>first var-set</i>
  Ddi_Varset_t * <b>v2</b> <i>second var-set</i>
)
</pre>
<dd> Return intersection of two var-sets. Result accumulated
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_VarsetUnion">Ddi_VarsetUnion</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiVarset.c"TARGET="ABSTRACT"><CODE>ddiVarset.c</CODE></A>

<dt><pre>
<A NAME="Ddi_VarsetIntersect"></A>
Ddi_Varset_t * <I></I>
<B>Ddi_VarsetIntersect</B>(
  Ddi_Varset_t * <b>v1</b>, <i>first var-set</i>
  Ddi_Varset_t * <b>v2</b> <i>second var-set</i>
)
</pre>
<dd> Return intersection of two var-sets. Result generated
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_VarsetUnion">Ddi_VarsetUnion</a>
<a href="#Ddi_VarsetIntersectAcc">Ddi_VarsetIntersectAcc</a>
<a href="#Ddi_VarsetDiff">Ddi_VarsetDiff</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiVarset.c"TARGET="ABSTRACT"><CODE>ddiVarset.c</CODE></A>

<dt><pre>
<A NAME="Ddi_VarsetIsVoid"></A>
int <I></I>
<B>Ddi_VarsetIsVoid</B>(
  Ddi_Varset_t * <b>varset</b> <i></i>
)
</pre>
<dd> Return true (non 0) if var-set is empty
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiVarset.c"TARGET="ABSTRACT"><CODE>ddiVarset.c</CODE></A>

<dt><pre>
<A NAME="Ddi_VarsetMakeFromArray"></A>
Ddi_Varset_t * <I></I>
<B>Ddi_VarsetMakeFromArray</B>(
  Ddi_Vararray_t * <b>va</b> <i></i>
)
</pre>
<dd> Build a Ddi_Varset_t from a given variable array.
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiVarset.c"TARGET="ABSTRACT"><CODE>ddiVarset.c</CODE></A>

<dt><pre>
<A NAME="Ddi_VarsetMakeFromCU"></A>
Ddi_Varset_t * <I></I>
<B>Ddi_VarsetMakeFromCU</B>(
  Ddi_Mgr_t * <b>mgr</b>, <i></i>
  DdNode * <b>bdd</b> <i></i>
)
</pre>
<dd> Builds the Ddi_Varset_t structure from manager and node.
               The reference count of the node is increased.
<p>

<dd> <b>See Also</b> <code><a href="#DdiGenericAlloc">DdiGenericAlloc</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiVarset.c"TARGET="ABSTRACT"><CODE>ddiVarset.c</CODE></A>

<dt><pre>
<A NAME="Ddi_VarsetMakeFromVar"></A>
Ddi_Varset_t * <I></I>
<B>Ddi_VarsetMakeFromVar</B>(
  Ddi_Var_t * <b>v</b> <i></i>
)
</pre>
<dd> Builds a Ddi_Varset_t structure from variable.
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_VarsetMakeFromCU">Ddi_VarsetMakeFromCU</a>
<a href="#Ddi_VarsetMakeFromArray">Ddi_VarsetMakeFromArray</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiVarset.c"TARGET="ABSTRACT"><CODE>ddiVarset.c</CODE></A>

<dt><pre>
<A NAME="Ddi_VarsetNextAcc"></A>
Ddi_Varset_t * <I></I>
<B>Ddi_VarsetNextAcc</B>(
  Ddi_Varset_t * <b>vs</b> <i></i>
)
</pre>
<dd> Remove top variable from var-set. Result accumulated
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiVarset.c"TARGET="ABSTRACT"><CODE>ddiVarset.c</CODE></A>

<dt><pre>
<A NAME="Ddi_VarsetNext"></A>
Ddi_Varset_t * <I></I>
<B>Ddi_VarsetNext</B>(
  Ddi_Varset_t * <b>vs</b> <i></i>
)
</pre>
<dd> Remove top variable from var-set. Result generated
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiVarset.c"TARGET="ABSTRACT"><CODE>ddiVarset.c</CODE></A>

<dt><pre>
<A NAME="Ddi_VarsetNum"></A>
int <I></I>
<B>Ddi_VarsetNum</B>(
  Ddi_Varset_t * <b>vars</b> <i>varset</i>
)
</pre>
<dd> Return the number of variables in varset
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiVarset.c"TARGET="ABSTRACT"><CODE>ddiVarset.c</CODE></A>

<dt><pre>
<A NAME="Ddi_VarsetPrint"></A>
void <I></I>
<B>Ddi_VarsetPrint</B>(
  Ddi_Varset_t * <b>vars</b>, <i>Varset to Print</i>
  int  <b>numberPerRow</b>, <i>Number of Names Printed on a Single Row</i>
  char * <b>filename</b>, <i>File Name</i>
  FILE * <b>fp</b> <i>output file pointer</i>
)
</pre>
<dd> If numberPerRow is less or equal to 0 all the names are
    printed-out on a single row.
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiVarset.c"TARGET="ABSTRACT"><CODE>ddiVarset.c</CODE></A>

<dt><pre>
<A NAME="Ddi_VarsetRemoveAcc"></A>
Ddi_Varset_t * <I></I>
<B>Ddi_VarsetRemoveAcc</B>(
  Ddi_Varset_t * <b>vs</b>, <i></i>
  Ddi_Var_t * <b>v</b> <i></i>
)
</pre>
<dd> Remove variable from var-set. Result is accumulated
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_VarsetAdd">Ddi_VarsetAdd</a>
<a href="#Ddi_VarsetRemove">Ddi_VarsetRemove</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiVarset.c"TARGET="ABSTRACT"><CODE>ddiVarset.c</CODE></A>

<dt><pre>
<A NAME="Ddi_VarsetRemove"></A>
Ddi_Varset_t * <I></I>
<B>Ddi_VarsetRemove</B>(
  Ddi_Varset_t * <b>vs</b>, <i></i>
  Ddi_Var_t * <b>v</b> <i></i>
)
</pre>
<dd> Remove variable from var-set. Result is generated
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_VarsetAdd">Ddi_VarsetAdd</a>
<a href="#Ddi_VarsetRemoveAcc">Ddi_VarsetRemoveAcc</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiVarset.c"TARGET="ABSTRACT"><CODE>ddiVarset.c</CODE></A>

<dt><pre>
<A NAME="Ddi_VarsetSubstVarsAcc"></A>
Ddi_Varset_t * <I></I>
<B>Ddi_VarsetSubstVarsAcc</B>(
  Ddi_Varset_t * <b>vs</b>, <i>input varset</i>
  Ddi_Vararray_t * <b>x</b>, <i>1-st array of variables</i>
  Ddi_Vararray_t * <b>y</b> <i>2-nd array of variables</i>
)
</pre>
<dd> Return a new varset with variable substitution x <- y.
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiVarset.c"TARGET="ABSTRACT"><CODE>ddiVarset.c</CODE></A>

<dt><pre>
<A NAME="Ddi_VarsetSubstVars"></A>
Ddi_Varset_t * <I></I>
<B>Ddi_VarsetSubstVars</B>(
  Ddi_Varset_t * <b>vs</b>, <i>input varset</i>
  Ddi_Vararray_t * <b>x</b>, <i>1-st array of variables</i>
  Ddi_Vararray_t * <b>y</b> <i>2-nd array of variables</i>
)
</pre>
<dd> Return a new varset with variable substitution x <- y.
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiVarset.c"TARGET="ABSTRACT"><CODE>ddiVarset.c</CODE></A>

<dt><pre>
<A NAME="Ddi_VarsetSwapVarsAcc"></A>
Ddi_Varset_t * <I></I>
<B>Ddi_VarsetSwapVarsAcc</B>(
  Ddi_Varset_t * <b>vs</b>, <i>input varset</i>
  Ddi_Vararray_t * <b>x</b>, <i>1-st array of variables</i>
  Ddi_Vararray_t * <b>y</b> <i>2-nd array of variables</i>
)
</pre>
<dd> Swap two sets of variables in varset. Result accumulated
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiVarset.c"TARGET="ABSTRACT"><CODE>ddiVarset.c</CODE></A>

<dt><pre>
<A NAME="Ddi_VarsetSwapVars"></A>
Ddi_Varset_t * <I></I>
<B>Ddi_VarsetSwapVars</B>(
  Ddi_Varset_t * <b>vs</b>, <i>input varset</i>
  Ddi_Vararray_t * <b>x</b>, <i>1-st array of variables</i>
  Ddi_Vararray_t * <b>y</b> <i>2-nd array of variables</i>
)
</pre>
<dd> Return a new varset with the variables swapped 
               (x replaces y and viceversa).
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiVarset.c"TARGET="ABSTRACT"><CODE>ddiVarset.c</CODE></A>

<dt><pre>
<A NAME="Ddi_VarsetToCU"></A>
Ddi_BddNode * <I></I>
<B>Ddi_VarsetToCU</B>(
  Ddi_Varset_t * <b>vs</b> <i></i>
)
</pre>
<dd> Convert a varset to a Cudd cube
<p>

<dd> <b>Side Effects</b> Convert a varset to a Cudd cube. 
    The returned node is NOT referenced
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_VarsetMakeFromCU">Ddi_VarsetMakeFromCU</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiVarset.c"TARGET="ABSTRACT"><CODE>ddiVarset.c</CODE></A>

<dt><pre>
<A NAME="Ddi_VarsetTop"></A>
Ddi_Var_t * <I></I>
<B>Ddi_VarsetTop</B>(
  Ddi_Varset_t * <b>varset</b> <i>var-set</i>
)
</pre>
<dd> Return the top variable (in the ordering) in varset
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_VarsetBottom">Ddi_VarsetBottom</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiVarset.c"TARGET="ABSTRACT"><CODE>ddiVarset.c</CODE></A>

<dt><pre>
<A NAME="Ddi_VarsetUnionAcc"></A>
Ddi_Varset_t * <I></I>
<B>Ddi_VarsetUnionAcc</B>(
  Ddi_Varset_t * <b>v1</b>, <i>first var-set</i>
  Ddi_Varset_t * <b>v2</b> <i>second var-set</i>
)
</pre>
<dd> Return union of two var-sets. Result accumulated
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_VarsetUnion">Ddi_VarsetUnion</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiVarset.c"TARGET="ABSTRACT"><CODE>ddiVarset.c</CODE></A>

<dt><pre>
<A NAME="Ddi_VarsetUnion"></A>
Ddi_Varset_t * <I></I>
<B>Ddi_VarsetUnion</B>(
  Ddi_Varset_t * <b>v1</b>, <i>first var-set</i>
  Ddi_Varset_t * <b>v2</b> <i>second var-set</i>
)
</pre>
<dd> Return union of two var-sets. Result generated
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_VarsetUnionAcc">Ddi_VarsetUnionAcc</a>
<a href="#Ddi_VarsetIntersect">Ddi_VarsetIntersect</a>
<a href="#Ddi_VarsetDiff">Ddi_VarsetDiff</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiVarset.c"TARGET="ABSTRACT"><CODE>ddiVarset.c</CODE></A>

<dt><pre>
<A NAME="Ddi_VarsetVoid"></A>
Ddi_Varset_t * <I></I>
<B>Ddi_VarsetVoid</B>(
  Ddi_BddMgr * <b>ddm</b> <i></i>
)
</pre>
<dd> The varset is generated, so it must eventually be freed
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiVarset.c"TARGET="ABSTRACT"><CODE>ddiVarset.c</CODE></A>

<dt><pre>
<A NAME="Ddi_VarsetWalkCurr"></A>
Ddi_Var_t * <I></I>
<B>Ddi_VarsetWalkCurr</B>(
  Ddi_Varset_t * <b>vs</b> <i></i>
)
</pre>
<dd> Return curr var in varset walk
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiVarset.c"TARGET="ABSTRACT"><CODE>ddiVarset.c</CODE></A>

<dt><pre>
<A NAME="Ddi_VarsetWalkEnd"></A>
int <I></I>
<B>Ddi_VarsetWalkEnd</B>(
  Ddi_Varset_t * <b>vs</b> <i></i>
)
</pre>
<dd> test for varset walk end. Return trur (non 0) if end reached
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiVarset.c"TARGET="ABSTRACT"><CODE>ddiVarset.c</CODE></A>

<dt><pre>
<A NAME="Ddi_VarsetWalkStart"></A>
void <I></I>
<B>Ddi_VarsetWalkStart</B>(
  Ddi_Varset_t * <b>vs</b> <i></i>
)
</pre>
<dd> Start Varset walk process. Set curr pointer to top BDD node
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiVarset.c"TARGET="ABSTRACT"><CODE>ddiVarset.c</CODE></A>

<dt><pre>
<A NAME="Ddi_VarsetWalkStep"></A>
void <I></I>
<B>Ddi_VarsetWalkStep</B>(
  Ddi_Varset_t * <b>vs</b> <i></i>
)
</pre>
<dd> Varset walk process step. Set curr pointer to next BDD node
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiVarset.c"TARGET="ABSTRACT"><CODE>ddiVarset.c</CODE></A>

<dt><pre>
<A NAME="Ddi_VarsetarrayAlloc"></A>
Ddi_Varsetarray_t * <I></I>
<B>Ddi_VarsetarrayAlloc</B>(
  Ddi_Mgr_t * <b>mgr</b>, <i>DDI manager</i>
  int  <b>length</b> <i>array length</i>
)
</pre>
<dd> Allocate a new array of varsets. The array slots are initialized 
    with NULL pointers, so further Write operations are required.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_VarsetarrayWrite">Ddi_VarsetarrayWrite</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiVarsetarray.c"TARGET="ABSTRACT"><CODE>ddiVarsetarray.c</CODE></A>

<dt><pre>
<A NAME="Ddi_VarsetarrayClear"></A>
void <I></I>
<B>Ddi_VarsetarrayClear</B>(
  Ddi_Varsetarray_t * <b>array</b>, <i>array of varsets</i>
  int  <b>pos</b> <i>position of element to be cleared</i>
)
</pre>
<dd> clear array at given position (BDD freed and replaced by NULL)
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_VarsetarrayRead">Ddi_VarsetarrayRead</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiVarsetarray.c"TARGET="ABSTRACT"><CODE>ddiVarsetarray.c</CODE></A>

<dt><pre>
<A NAME="Ddi_VarsetarrayCopy"></A>
Ddi_Varsetarray_t * <I></I>
<B>Ddi_VarsetarrayCopy</B>(
  Ddi_BddMgr * <b>ddm</b>, <i>dd Manager</i>
  Ddi_Varsetarray_t * <b>old</b> <i>array of varsets</i>
)
</pre>
<dd> Copy an array of varsets to a destination manager.
    Variable correspondence is established "by index", i.e. 
    variables with same index in different manager correspond
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_VarsetarrayDup">Ddi_VarsetarrayDup</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiVarsetarray.c"TARGET="ABSTRACT"><CODE>ddiVarsetarray.c</CODE></A>

<dt><pre>
<A NAME="Ddi_VarsetarrayDup"></A>
Ddi_Varsetarray_t * <I></I>
<B>Ddi_VarsetarrayDup</B>(
  Ddi_Varsetarray_t * <b>old</b> <i>array to be duplicated</i>
)
</pre>
<dd> Duplicate an array of Varsets
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_VarsetarrayAlloc">Ddi_VarsetarrayAlloc</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiVarsetarray.c"TARGET="ABSTRACT"><CODE>ddiVarsetarray.c</CODE></A>

<dt><pre>
<A NAME="Ddi_VarsetarrayInsertLast"></A>
void <I></I>
<B>Ddi_VarsetarrayInsertLast</B>(
  Ddi_Varsetarray_t * <b>array</b>, <i>array of varsets</i>
  Ddi_Varset_t * <b>vs</b> <i>varset to be written</i>
)
</pre>
<dd> Insert varset in array at last position. 
    The written varset is duplicated
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_VarsetarrayInsert">Ddi_VarsetarrayInsert</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiVarsetarray.c"TARGET="ABSTRACT"><CODE>ddiVarsetarray.c</CODE></A>

<dt><pre>
<A NAME="Ddi_VarsetarrayInsert"></A>
void <I></I>
<B>Ddi_VarsetarrayInsert</B>(
  Ddi_Varsetarray_t * <b>array</b>, <i>array of varsets</i>
  int  <b>pos</b>, <i>position of new element</i>
  Ddi_Varset_t * <b>vs</b> <i>varset to be written</i>
)
</pre>
<dd> Insert varset in array at given position. 
    Previous non NULL entry is moved up. The written varset is duplicated
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_VarsetarrayRead">Ddi_VarsetarrayRead</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiVarsetarray.c"TARGET="ABSTRACT"><CODE>ddiVarsetarray.c</CODE></A>

<dt><pre>
<A NAME="Ddi_VarsetarrayNum"></A>
int <I></I>
<B>Ddi_VarsetarrayNum</B>(
  Ddi_Varsetarray_t * <b>array</b> <i></i>
)
</pre>
<dd> Return the number of entries in array
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiVarsetarray.c"TARGET="ABSTRACT"><CODE>ddiVarsetarray.c</CODE></A>

<dt><pre>
<A NAME="Ddi_VarsetarrayRead"></A>
Ddi_Varset_t * <I></I>
<B>Ddi_VarsetarrayRead</B>(
  Ddi_Varsetarray_t * <b>array</b>, <i>varset array</i>
  int  <b>i</b> <i>position</i>
)
</pre>
<dd> Read varset at i-th position in array. As all read operations
    no data duplication is done, so the returned varset should be duplicated
    if further manipulations are required on it.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_VarsetarrayWrite">Ddi_VarsetarrayWrite</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiVarsetarray.c"TARGET="ABSTRACT"><CODE>ddiVarsetarray.c</CODE></A>

<dt><pre>
<A NAME="Ddi_VarsetarrayWrite"></A>
void <I></I>
<B>Ddi_VarsetarrayWrite</B>(
  Ddi_Varsetarray_t * <b>array</b>, <i>array of varsets</i>
  int  <b>pos</b>, <i>position of new element</i>
  Ddi_Varset_t * <b>vs</b> <i>varset to be written</i>
)
</pre>
<dd> Write varset in array at given position. Previous non NULL entry
    is freed. The written varset is duplicated
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_VarsetarrayRead">Ddi_VarsetarrayRead</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiVarsetarray.c"TARGET="ABSTRACT"><CODE>ddiVarsetarray.c</CODE></A>

<dt><pre>
<A NAME="GenBddRootsRecur"></A>
static void <I></I>
<B>GenBddRootsRecur</B>(
  Ddi_Generic_t * <b>f</b>, <i></i>
  Ddi_ArrayData_t * <b>roots</b> <i></i>
)
</pre>
<dd> Recursive step of root pointers generation
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#GenBddRoots">GenBddRoots</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiGeneric.c"TARGET="ABSTRACT"><CODE>ddiGeneric.c</CODE></A>

<dt><pre>
<A NAME="GenBddRoots"></A>
static Ddi_ArrayData_t * <I></I>
<B>GenBddRoots</B>(
  Ddi_Generic_t * <b>f</b> <i></i>
)
</pre>
<dd> Recursively visits a partitioned Dd structure and builds
                the array of leaves bdds. The array is used by functions
                counting BDD nodes, computing support, printing/storing
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#GenPartRootsRecur">GenPartRootsRecur</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiGeneric.c"TARGET="ABSTRACT"><CODE>ddiGeneric.c</CODE></A>

<dt><pre>
<A NAME="GenericDupIntern"></A>
static Ddi_Generic_t * <I></I>
<B>GenericDupIntern</B>(
  Ddi_Generic_t * <b>r</b>, <i>destination</i>
  Ddi_Generic_t * <b>f</b> <i>source</i>
)
</pre>
<dd> Duplicate a DDI node
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiGeneric.c"TARGET="ABSTRACT"><CODE>ddiGeneric.c</CODE></A>

<dt><pre>
<A NAME="GenericFreeIntern"></A>
static void <I></I>
<B>GenericFreeIntern</B>(
  Ddi_Generic_t * <b>f</b> <i>block to be freed</i>
)
</pre>
<dd> Frees a generic block. Internal procedure
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiGeneric.c"TARGET="ABSTRACT"><CODE>ddiGeneric.c</CODE></A>

<dt><pre>
<A NAME="MetaConstrainOpt"></A>
static Ddi_Bdd_t * <I></I>
<B>MetaConstrainOpt</B>(
  Ddi_Bdd_t * <b>f</b>, <i></i>
  Ddi_Bdd_t * <b>g</b> <i></i>
)
</pre>
<dd> return constrain only if size reduced
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiMeta.c"TARGET="ABSTRACT"><CODE>ddiMeta.c</CODE></A>

<dt><pre>
<A NAME="MetaConvertBdd"></A>
static void <I></I>
<B>MetaConvertBdd</B>(
  Ddi_Generic_t * <b>f</b>, <i></i>
  Meta_Convert_e  <b>sel</b> <i></i>
)
</pre>
<dd> Conversion between BDD and Meta BDD
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiMeta.c"TARGET="ABSTRACT"><CODE>ddiMeta.c</CODE></A>

<dt><pre>
<A NAME="MetaConvert"></A>
static Ddi_Generic_t * <I></I>
<B>MetaConvert</B>(
  Ddi_Generic_t * <b>f</b>, <i></i>
  Meta_Convert_e  <b>sel</b> <i></i>
)
</pre>
<dd> Transform between generic DDI node and Meta BDD. 
    Result accumulated. The transformation is applied to leaf BDDs, 
    whereas the DDI structure is kept as it is
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiMeta.c"TARGET="ABSTRACT"><CODE>ddiMeta.c</CODE></A>

<dt><pre>
<A NAME="MetaFromMono"></A>
static void <I></I>
<B>MetaFromMono</B>(
  Ddi_Bdd_t * <b>f</b> <i></i>
)
</pre>
<dd> Transform a BDD to Meta BDD
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiMeta.c"TARGET="ABSTRACT"><CODE>ddiMeta.c</CODE></A>

<dt><pre>
<A NAME="MetaLinearAndExistAcc"></A>
static Ddi_Bdd_t * <I></I>
<B>MetaLinearAndExistAcc</B>(
  Ddi_Bdd_t * <b>fMeta</b>, <i></i>
  Ddi_Bdd_t * <b>gBdd</b>, <i></i>
  Ddi_Varset_t * <b>smooth</b> <i></i>
)
</pre>
<dd> Operate And-Exist between Meta BDD and conj. part. BDD
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiMeta.c"TARGET="ABSTRACT"><CODE>ddiMeta.c</CODE></A>

<dt><pre>
<A NAME="MetaReduce"></A>
static void <I></I>
<B>MetaReduce</B>(
  Ddi_Bdd_t * <b>f</b>, <i></i>
  int  <b>init</b> <i>start from this layer: < 0 for full reduction</i>
)
</pre>
<dd> Apply bottom-up reduction process to meta BDD
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiMeta.c"TARGET="ABSTRACT"><CODE>ddiMeta.c</CODE></A>

<dt><pre>
<A NAME="MetaSetConj"></A>
static void <I></I>
<B>MetaSetConj</B>(
  Ddi_Bdd_t * <b>f</b> <i></i>
)
</pre>
<dd> Apply top-down reduction of ones to bottom layer. This reduces
    a Meta BDD to a conjunctive form
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiMeta.c"TARGET="ABSTRACT"><CODE>ddiMeta.c</CODE></A>

<dt><pre>
<A NAME="MetaSimplify"></A>
static void <I></I>
<B>MetaSimplify</B>(
  Ddi_Bdd_t * <b>f</b>, <i></i>
  int  <b>init</b>, <i>apply simplification starting from this layer</i>
  int  <b>end</b> <i></i>
)
</pre>
<dd> Apply top-down cofactor based simplification
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiMeta.c"TARGET="ABSTRACT"><CODE>ddiMeta.c</CODE></A>

<dt><pre>
<A NAME="MetaToMono"></A>
static void <I></I>
<B>MetaToMono</B>(
  Ddi_Bdd_t * <b>f</b> <i></i>
)
</pre>
<dd> Transform a Meta BDD to monolitic BDD
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiMeta.c"TARGET="ABSTRACT"><CODE>ddiMeta.c</CODE></A>

<dt><pre>
<A NAME="MetaUpdate"></A>
static int <I></I>
<B>MetaUpdate</B>(
  Ddi_Mgr_t * <b>ddm</b> <i></i>
)
</pre>
<dd> Update Meta handling by calling Init. This is activated if 
    new variables have been created or reordering has taken place from 
    previous. Return true (non 0) if activated
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddiMeta.c"TARGET="ABSTRACT"><CODE>ddiMeta.c</CODE></A>

<dt><pre>
<A NAME=""></A>
 <I></I>
<B></B>(
   <b></b> <i></i>
)
</pre>
<dd> Compute
    unary, binary or tenary operation returning a BDD. Result is generated.
    Requires an operation code and three operand parameters.
    It is also available in the ...Opi version, where i = 1, 2, or 3, is
    the number of operands.
    The same functions are also available in the accumulated version.
    The complete list of related functions follows:
    <ul>
    <li>   Ddi_BddOp(op,f,g,h)
    <li>   Ddi_BddOp1(op,f)    
    <li>   Ddi_BddOp2(op,f,g)  
    <li>   Ddi_BddOp3(op,f,g,h)
    <li>   Ddi_BddOpAcc(op,f,g,h)
    <li>   Ddi_BddOpAcc1(op,f)    
    <li>   Ddi_BddOpAcc2(op,f,g)  
    <li>   Ddi_BddOpAcc3(op,f,g,h)
    </ul>
    whereas the list of available operation codes is:
    <ul>
    <li>   Ddi_BddNot_c,
    <li>   Ddi_BddSwapVars_c,
    <li>   Ddi_BddMakeMono_c,
    <li>   Ddi_BddAnd_c,
    <li>   Ddi_BddDiff_c,
    <li>   Ddi_BddNand_c,
    <li>   Ddi_BddOr_c,
    <li>   Ddi_BddNor_c,
    <li>   Ddi_BddXor_c,
    <li>   Ddi_BddXnor_c,
    <li>   Ddi_BddExist_c,
    <li>   Ddi_BddForall_c,
    <li>   Ddi_BddConstrain_c,
    <li>   Ddi_BddRestrict_c,
    <li>   Ddi_BddCproject_c,
    <li>   Ddi_BddAndExist_c,
    <li>   Ddi_BddIte_c,
    <li>   Ddi_BddSupp_c,
    <li>   Ddi_BddSuppAttach_c,
    <li>   Ddi_BddSuppDetach_c,
    </ul>
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_BddarrayOp">Ddi_BddarrayOp</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddi.h"TARGET="ABSTRACT"><CODE>ddi.h</CODE></A>

<dt><pre>
<A NAME=""></A>
 <I></I>
<B></B>(
   <b></b> <i></i>
)
</pre>
<dd> The function, for all elements of the array, computes
    unary, binary or tenary operation involving the <em>i-th</em> element 
    of the array. Result is generated.
    The function requires an operation code and three operand parameters.
    It is also available in the ...Op<i> version, where <i> = 1, 2, or 3, is
    the number of operands.
    All functions operate in accumulated mode, i.e. they modify the first 
    parameter instead of generating a new array.
    The complete list of related functions follows:
    </ul>
    <li>   Ddi_BddarrayOp(op,f,g,h)
    <li>   Ddi_BddarrayOp1(op,f)    
    <li>   Ddi_BddarrayOp2(op,f,g)  
    <li>   Ddi_BddarrayOp3(op,f,g,h)
    </ul>
<p>

<dd> <b>See Also</b> <code><a href="#Ddi_BddOp">Ddi_BddOp</a>
</code>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddi.h"TARGET="ABSTRACT"><CODE>ddi.h</CODE></A>

<dt><pre>
<A NAME=""></A>
 <I></I>
<B></B>(
   <b></b> <i></i>
)
</pre>
<dd> Free DDI node (compatible with all DDI handles).
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddi.h"TARGET="ABSTRACT"><CODE>ddi.h</CODE></A>

<dt><pre>
<A NAME=""></A>
 <I></I>
<B></B>(
   <b></b> <i></i>
)
</pre>
<dd> Lock DDI node so that cannot be freed unless unlocked.
    Used as a protection mechanism for internal objects (array entries,
    partitions, ...
<p>

<dd> <b>Side Effects</b> Ddi_Unlock
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddi.h"TARGET="ABSTRACT"><CODE>ddi.h</CODE></A>

<dt><pre>
<A NAME=""></A>
 <I></I>
<B></B>(
   <b></b> <i></i>
)
</pre>
<dd> Read handle code. The code field of DDI nodes is a sort of 
    subtype. In case of BDDs, it selects among monolithic, partitioned and 
    meta formats. In other cases it is not used.
    Allowed return values are:
    <ul> 
    <li> Ddi_Bdd_Mono_c (monolithic BDD)
    <li> Ddi_Bdd_Part_Conj_c (disjunctively partitioned BDD)
    <li> Ddi_Bdd_Part_Disj_c (conjunctively partitioned BDD)
    <li> Ddi_Bdd_Meta_c (meta BDD)
    <li> Ddi_Expr_Op_c (operation node in expressions)
    <li> Ddi_Expr_String_c (string identifier terminal node of expressions)
    <li> Ddi_Expr_Bdd_c (BDD terminal of expressions)
    <li> Ddi_Null_code_c (no BDD pointed, possibly wrong DDI node)
    </ul>
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddi.h"TARGET="ABSTRACT"><CODE>ddi.h</CODE></A>

<dt><pre>
<A NAME=""></A>
 <I></I>
<B></B>(
   <b></b> <i></i>
)
</pre>
<dd> Read name field of DDI node
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddi.h"TARGET="ABSTRACT"><CODE>ddi.h</CODE></A>

<dt><pre>
<A NAME=""></A>
 <I></I>
<B></B>(
   <b></b> <i></i>
)
</pre>
<dd> Read the DDI Manager field. This is a pointer to the owner 
    DDI manager.
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddi.h"TARGET="ABSTRACT"><CODE>ddi.h</CODE></A>

<dt><pre>
<A NAME=""></A>
 <I></I>
<B></B>(
   <b></b> <i></i>
)
</pre>
<dd> Read the name field. Mainly thought for debug/report purposes.
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddi.h"TARGET="ABSTRACT"><CODE>ddi.h</CODE></A>

<dt><pre>
<A NAME=""></A>
 <I></I>
<B></B>(
   <b></b> <i></i>
)
</pre>
<dd> Set name field of DDI node
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddi.h"TARGET="ABSTRACT"><CODE>ddi.h</CODE></A>

<dt><pre>
<A NAME=""></A>
 <I></I>
<B></B>(
   <b></b> <i></i>
)
</pre>
<dd> Unlock DDI node so that can be freed again.
<p>

<dd> <b>Side Effects</b> Ddi_Lock
<p>

<DD> <B>Defined in </B> <A HREF="ddiAllFile.html#ddi.h"TARGET="ABSTRACT"><CODE>ddi.h</CODE></A>


</DL>
<HR>
Last updated on 1010515 11h48
</BODY></HTML>
