#ifdef __cplusplus
extern "C" {
#endif
/* 
 * File: TCgen.c
 *
 * Code gathered from online submission form for TCgen.  It has been modified to
 * properly fit the framework for TMT.
 *
 * Changes:
 *   - modified F*type's to use appropriate glib types
 *   - moved assertions from main to Init
 *   - renamed Init to TGgen_Init
 *   - remove static from encodes/decodes
 *
 * Removed: main, Open, Decompress, Commit, Compress
 */

/*
TCgen V1.0
compiling

# This spec is intended to compress TmtDynamicOpers
TCgen Trace Specification;
0-Bit Header;
32-Bit Field 1 = {L1 = 1, L2 = 131072: FCM3[2]}; # oper_id
32-Bit Field 2 = {L1 = 65536, L2 = 131072: FCM3[1]}; #attr
64-Bit Field 3 = {L1 = 65536, L2 = 131072: DFCM3[1]}; #src_ea0
64-Bit Field 4 = {L1 = 65536, L2 = 131072: DFCM3[1]}; #src_ea1
64-Bit Field 5 = {L1 = 65536, L2 = 131072: DFCM3[1]}; #dst_ea0
32-Bit Field 6 = {L1 = 65536, L2 = 131072: FCM3[1]}; #mem_read_size
32-Bit Field 7 = {L1 = 65536, L2 = 131072: FCM3[1]}; #mem_write_size
32-Bit Field 8 = {L1 = 65536, L2 = 131072: FCM3[1]}; #sys
PC = Field 1;

-----

TCgen Trace Specification;

0-Bit Header;

32-Bit Field 1 = {L1 = 1, L2 = 131072: FCM3[2]};
# Field 1 uses 2 predictors with a combined size of 4194316 bytes (4.0MB)

32-Bit Field 2 = {L1 = 65536, L2 = 131072: FCM3[1]};
# Field 2 uses 1 predictors with a combined size of 2883584 bytes (2.8MB)

64-Bit Field 3 = {L1 = 65536, L2 = 131072: DFCM3[1]};
# Field 3 uses 1 predictors with a combined size of 5505024 bytes (5.2MB)

64-Bit Field 4 = {L1 = 65536, L2 = 131072: DFCM3[1]};
# Field 4 uses 1 predictors with a combined size of 5505024 bytes (5.2MB)

64-Bit Field 5 = {L1 = 65536, L2 = 131072: DFCM3[1]};
# Field 5 uses 1 predictors with a combined size of 5505024 bytes (5.2MB)

32-Bit Field 6 = {L1 = 65536, L2 = 131072: FCM3[1]};
# Field 6 uses 1 predictors with a combined size of 2883584 bytes (2.8MB)

32-Bit Field 7 = {L1 = 65536, L2 = 131072: FCM3[1]};
# Field 7 uses 1 predictors with a combined size of 2883584 bytes (2.8MB)

32-Bit Field 8 = {L1 = 65536, L2 = 131072: FCM3[1]};
# Field 8 uses 1 predictors with a combined size of 2883584 bytes (2.8MB)

PC = Field 1;

-----

Copyright (c) 2004 Cornell Research Foundation, Inc.  All rights reserved.
Author:  Professor Martin Burtscher
 
Software License Terms and Conditions

1. SOFTWARE shall mean the TCgen tool available on the web page
   http://www.csl.cornell.edu/~burtscher/research/TCgen/ and described in
   Cornell Research Foundation, Inc. ("CRF") file D-3577.  SOFTWARE OUTPUT
   CODE shall mean any code generated by the SOFTWARE.  SOFTWARE OUTPUT CODE
   includes, but is not limited to, source code, object code and executable
   code.  SOFTWARE and SOFTWARE OUTPUT CODE shall collectively be referred to
   herein as TCgen SOFTWARE.

2. CRF is a wholly owned subsidiary of Cornell University, is a fiduciary of
   Cornell University in intellectual property matters and holds all
   intellectual property rights in TCgen SOFTWARE.  

3. LICENSEE means the party to this Agreement and the user of TCgen SOFTWARE.
   By using TCgen SOFTWARE, LICENSEE enters into this Agreement with CRF.  

4. TCgen SOFTWARE is made available under this Agreement to allow certain
   non-commercial research and teaching use.  CRF reserves all commercial
   rights to TCgen SOFTWARE and these rights may be licensed by CRF to third
   parties.  

5. LICENSEE is hereby granted permission to:  a) use SOFTWARE for
   non-commercial research or teaching purposes, and b) download, compile,
   execute, copy, and modify SOFTWARE OUTPUT CODE for non-commercial research
   or teaching purposes provided that this notice accompanies all copies of
   SOFTWARE OUTPUT CODE.  Copies of modified SOFTWARE OUTPUT CODE may be
   distributed only for non-commercial research or teaching purposes (i) if
   this notice accompanies those copies, (ii) if said copies carry prominent
   notices stating that SOFTWARE OUTPUT CODE has been changed, and (iii) the
   date of any changes are clearly identified in SOFTWARE OUTPUT CODE.  

6. CRF may terminate this Agreement at any time if LICENSEE breaches a
   material provision of this Agreement.  CRF may also terminate this
   Agreement if the TCgen SOFTWARE becomes subject to any claim of
   infringement of patent, copyright or trade secret, or if in CRF'S opinion
   such a claim is likely to occur.  

7. LICENSEE agrees that the export of TCgen SOFTWARE from the United States
   may require approval from the U.S. government and failure to obtain such
   approval will result in the immediate termination of this license and may
   result in criminal liability under U.S. laws.

8. The work leading to the development of SOFTWARE was supported in part by
   various grants from an agency of the U.S. Government, and CRF is obligated
   to comply with U.S. OMB Circular A-124 and 37 CFR Part 401.  This license
   is subject to the applicable terms of U.S. Government regulations
   concerning Government funded inventions.

9. CRF provides TCgen SOFTWARE on an "as is" basis.  CRF does not warrant,
   guarantee, or make any representations regarding the use or results of
   TCgen SOFTWARE with respect to its correctness, accuracy, reliability or
   performance.  The entire risk of the use and performance of TCgen
   SOFTWARE is assumed by LICENSEE.  ALL WARRANTIES INCLUDING, WITHOUT
   LIMITATION, ANY WARRANTY OF FITNESS FOR A PARTICULAR PURPOSE OR
   MERCHANTABILITY AND ANY WARRANTY OF NONINFRINGEMENT OF PATENTS,
   COPYRIGHTS, OR ANY OTHER INTELLECTUAL PROPERTY RIGHT ARE HEREBY EXCLUDED.

10. LICENSEE understands and agrees that neither CRF nor Cornell University
    is under any obligation to provide maintenance, support or update
    services, notices of latent defects, correction of defects, or future
    versions for TCgen SOFTWARE.  

11. Even if advised of the possibility of damages, under no circumstances
    shall CRF or Cornell University individually or jointly be liable to
    LICENSEE or any third party for damages of any character, including,
    without limitation, direct, indirect, incidental, consequential or
    special damages, loss of profits, loss of use, loss of goodwill,
    computer failure or malfunction.  LICENSEE agrees to indemnify and
    hold harmless CRF and Cornell University for any and all liability CRF
    or Cornell University may incur as a result of use of TCgen SOFTWARE
    by LICENSEE. 
*/


#include <stdlib.h>
#include <stdio.h>
#include <assert.h>
#include <glib.h>
#include "TCgen.h"

static long long F0usecnt[3];
static int F0fhash[1][3];
static F0type F0fcm2[524288][2];

static long long F1usecnt[2];
static int F1fhash[65536][3];
static F1type F1fcm2[524288][1];

static long long F2usecnt[2];
static int F2dhash[65536][3];
static F2type F2dfcm2[524288][1];
static F2type F2lv[65536][1];

static long long F3usecnt[2];
static int F3dhash[65536][3];
static F3type F3dfcm2[524288][1];
static F3type F3lv[65536][1];

static long long F4usecnt[2];
static int F4dhash[65536][3];
static F4type F4dfcm2[524288][1];
static F4type F4lv[65536][1];

static long long F5usecnt[2];
static int F5fhash[65536][3];
static F5type F5fcm2[524288][1];

static long long F6usecnt[2];
static int F6fhash[65536][3];
static F6type F6fcm2[524288][1];

static long long F7usecnt[2];
static int F7fhash[65536][3];
static F7type F7fcm2[524288][1];


void TCgen_Init()
{
  register int i, j;
  static gboolean ran = FALSE;

  if (ran) g_error("TCgen doesn't currently allow multiple initializations\n");
  ran = TRUE;

  assert(sizeof(char) == 1);
  assert(sizeof(short) == 2);
  assert(sizeof(int) == 4);
  assert(sizeof(long long) == 8);

  for (i = 0; i <= 2; i++) F0usecnt[i] = 0;
  for (i = 0; i < 1; i++) {
    for (j = 0; j < 3; j++) F0fhash[i][j] = 0;
  }
  for (i = 0; i < 524288; i++) {
    for (j = 0; j < 2; j++) F0fcm2[i][j] = j;
  }
  for (i = 0; i <= 1; i++) F1usecnt[i] = 0;
  for (i = 0; i < 65536; i++) {
    for (j = 0; j < 3; j++) F1fhash[i][j] = 0;
  }
  for (i = 0; i < 524288; i++) {
    for (j = 0; j < 1; j++) F1fcm2[i][j] = j;
  }
  for (i = 0; i <= 1; i++) F2usecnt[i] = 0;
  for (i = 0; i < 65536; i++) {
    for (j = 0; j < 3; j++) F2dhash[i][j] = 0;
  }
  for (i = 0; i < 524288; i++) {
    for (j = 0; j < 1; j++) F2dfcm2[i][j] = j;
  }
  for (i = 0; i < 65536; i++) {
    for (j = 0; j < 1; j++) F2lv[i][j] = j;
  }
  for (i = 0; i <= 1; i++) F3usecnt[i] = 0;
  for (i = 0; i < 65536; i++) {
    for (j = 0; j < 3; j++) F3dhash[i][j] = 0;
  }
  for (i = 0; i < 524288; i++) {
    for (j = 0; j < 1; j++) F3dfcm2[i][j] = j;
  }
  for (i = 0; i < 65536; i++) {
    for (j = 0; j < 1; j++) F3lv[i][j] = j;
  }
  for (i = 0; i <= 1; i++) F4usecnt[i] = 0;
  for (i = 0; i < 65536; i++) {
    for (j = 0; j < 3; j++) F4dhash[i][j] = 0;
  }
  for (i = 0; i < 524288; i++) {
    for (j = 0; j < 1; j++) F4dfcm2[i][j] = j;
  }
  for (i = 0; i < 65536; i++) {
    for (j = 0; j < 1; j++) F4lv[i][j] = j;
  }
  for (i = 0; i <= 1; i++) F5usecnt[i] = 0;
  for (i = 0; i < 65536; i++) {
    for (j = 0; j < 3; j++) F5fhash[i][j] = 0;
  }
  for (i = 0; i < 524288; i++) {
    for (j = 0; j < 1; j++) F5fcm2[i][j] = j;
  }
  for (i = 0; i <= 1; i++) F6usecnt[i] = 0;
  for (i = 0; i < 65536; i++) {
    for (j = 0; j < 3; j++) F6fhash[i][j] = 0;
  }
  for (i = 0; i < 524288; i++) {
    for (j = 0; j < 1; j++) F6fcm2[i][j] = j;
  }
  for (i = 0; i <= 1; i++) F7usecnt[i] = 0;
  for (i = 0; i < 65536; i++) {
    for (j = 0; j < 3; j++) F7fhash[i][j] = 0;
  }
  for (i = 0; i < 524288; i++) {
    for (j = 0; j < 1; j++) F7fcm2[i][j] = j;
  }

}


static inline int Hash8(unsigned long long x, const int bits)
{
  register int res = 0;

  while (x > 0) {
    res ^= x;
    x = (unsigned long long)x >> bits;
  }
  return (res & ((1<<bits)-1));
}


static inline int Hash4(unsigned int x, const int bits)
{
  register int res = 0;

  while (x > 0) {
    res ^= x;
    x = (unsigned int)x >> bits;
  }
  return (res & ((1<<bits)-1));
}


static inline int Hash2(unsigned short x, const int bits)
{
  register int res = 0;

  while (x > 0) {
    res ^= x;
    x = (unsigned short)x >> bits;
  }
  return (res & ((1<<bits)-1));
}


static inline int Hash1(unsigned char x, const int bits)
{
  register int res = 0;

  while (x > 0) {
    res ^= x;
    x = (unsigned char)x >> bits;
  }
  return (res & ((1<<bits)-1));
}


F0type F0Decode(const int code, F0type val)
{
  register int hash, idx;

  idx = 0;
  switch (code) {
    case 0: val = F0fcm2[F0fhash[idx][2]][0]; break;
    case 1: val = F0fcm2[F0fhash[idx][2]][1]; break;
    case 2: break;
    default: printf("unrecognized code encountered\n"); exit(EXIT_FAILURE); break;
  }

  hash = F0fhash[idx][2];
  if (F0fcm2[hash][0] != val)
  {
    F0fcm2[hash][1] = F0fcm2[hash][0];
    F0fcm2[hash][0] = val;
  }
  hash = Hash4(val, 17);
  F0fhash[idx][2] = (F0fhash[idx][1] << 1) ^ hash;
  F0fhash[idx][1] = (F0fhash[idx][0] << 1) ^ hash;
  F0fhash[idx][0] = hash;

  return val;
}


F1type F1Decode(const int code, const PCtype pc, F1type val)
{
  register int hash, idx;

  idx = pc & 65535;
  switch (code) {
    case 0: val = F1fcm2[F1fhash[idx][2]][0]; break;
    case 1: break;
    default: printf("unrecognized code encountered\n"); exit(EXIT_FAILURE); break;
  }

  hash = F1fhash[idx][2];
  {
    F1fcm2[hash][0] = val;
  }
  hash = Hash4(val, 17);
  F1fhash[idx][2] = (F1fhash[idx][1] << 1) ^ hash;
  F1fhash[idx][1] = (F1fhash[idx][0] << 1) ^ hash;
  F1fhash[idx][0] = hash;

  return val;
}


F2type F2Decode(const int code, const PCtype pc, F2type val)
{
  register int hash, idx;
  register F2type stride;

  idx = pc & 65535;
  switch (code) {
    case 0: val = F2dfcm2[F2dhash[idx][2]][0] + F2lv[idx][0]; break;
    case 1: break;
    default: printf("unrecognized code encountered\n"); exit(EXIT_FAILURE); break;
  }

  stride = val - F2lv[idx][0];
  hash = F2dhash[idx][2];
  {
    F2dfcm2[hash][0] = stride;
  }
  hash = Hash8(stride, 17);
  F2dhash[idx][2] = (F2dhash[idx][1] << 1) ^ hash;
  F2dhash[idx][1] = (F2dhash[idx][0] << 1) ^ hash;
  F2dhash[idx][0] = hash;

  {
    F2lv[idx][0] = val;
  }

  return val;
}


F3type F3Decode(const int code, const PCtype pc, F3type val)
{
  register int hash, idx;
  register F3type stride;

  idx = pc & 65535;
  switch (code) {
    case 0: val = F3dfcm2[F3dhash[idx][2]][0] + F3lv[idx][0]; break;
    case 1: break;
    default: printf("unrecognized code encountered\n"); exit(EXIT_FAILURE); break;
  }

  stride = val - F3lv[idx][0];
  hash = F3dhash[idx][2];
  {
    F3dfcm2[hash][0] = stride;
  }
  hash = Hash8(stride, 17);
  F3dhash[idx][2] = (F3dhash[idx][1] << 1) ^ hash;
  F3dhash[idx][1] = (F3dhash[idx][0] << 1) ^ hash;
  F3dhash[idx][0] = hash;

  {
    F3lv[idx][0] = val;
  }

  return val;
}


F4type F4Decode(const int code, const PCtype pc, F4type val)
{
  register int hash, idx;
  register F4type stride;

  idx = pc & 65535;
  switch (code) {
    case 0: val = F4dfcm2[F4dhash[idx][2]][0] + F4lv[idx][0]; break;
    case 1: break;
    default: printf("unrecognized code encountered\n"); exit(EXIT_FAILURE); break;
  }

  stride = val - F4lv[idx][0];
  hash = F4dhash[idx][2];
  {
    F4dfcm2[hash][0] = stride;
  }
  hash = Hash8(stride, 17);
  F4dhash[idx][2] = (F4dhash[idx][1] << 1) ^ hash;
  F4dhash[idx][1] = (F4dhash[idx][0] << 1) ^ hash;
  F4dhash[idx][0] = hash;

  {
    F4lv[idx][0] = val;
  }

  return val;
}


F5type F5Decode(const int code, const PCtype pc, F5type val)
{
  register int hash, idx;

  idx = pc & 65535;
  switch (code) {
    case 0: val = F5fcm2[F5fhash[idx][2]][0]; break;
    case 1: break;
    default: printf("unrecognized code encountered\n"); exit(EXIT_FAILURE); break;
  }

  hash = F5fhash[idx][2];
  {
    F5fcm2[hash][0] = val;
  }
  hash = Hash4(val, 17);
  F5fhash[idx][2] = (F5fhash[idx][1] << 1) ^ hash;
  F5fhash[idx][1] = (F5fhash[idx][0] << 1) ^ hash;
  F5fhash[idx][0] = hash;

  return val;
}


F6type F6Decode(const int code, const PCtype pc, F6type val)
{
  register int hash, idx;

  idx = pc & 65535;
  switch (code) 
  {
    case 0: val = F6fcm2[F6fhash[idx][2]][0]; break;
    case 1: break;
    default: printf("unrecognized code encountered\n"); exit(EXIT_FAILURE); break;
  }

  hash = F6fhash[idx][2];
  {
    F6fcm2[hash][0] = val;
  }
  hash = Hash4(val, 17);
  F6fhash[idx][2] = (F6fhash[idx][1] << 1) ^ hash;
  F6fhash[idx][1] = (F6fhash[idx][0] << 1) ^ hash;
  F6fhash[idx][0] = hash;

  return val;
}


F7type F7Decode(const int code, const PCtype pc, F7type val)
{
  register int hash, idx;

  idx = pc & 65535;
  switch (code) {
    case 0: val = F7fcm2[F7fhash[idx][2]][0]; break;
    case 1: break;
    default: printf("unrecognized code encountered\n"); exit(EXIT_FAILURE); break;
  }

  hash = F7fhash[idx][2];
  {
    F7fcm2[hash][0] = val;
  }
  hash = Hash4(val, 17);
  F7fhash[idx][2] = (F7fhash[idx][1] << 1) ^ hash;
  F7fhash[idx][1] = (F7fhash[idx][0] << 1) ^ hash;
  F7fhash[idx][0] = hash;

  return val;
}


unsigned char F0Encode(const F0type val)
{
  register unsigned char code;
  register int hash, idx;
  register long long hicnt;

  idx = 0;
  code = 2;
  hicnt = -1;

  hash = F0fhash[idx][2];
  if ((F0usecnt[0] > hicnt) && (val == F0fcm2[hash][0])) {
    code = 0;
    hicnt = F0usecnt[0];
  }
  if ((F0usecnt[1] > hicnt) && (val == F0fcm2[hash][1])) {
    code = 1;
    hicnt = F0usecnt[1];
  }
  if (F0fcm2[hash][0] != val)
  {
    F0fcm2[hash][1] = F0fcm2[hash][0];
    F0fcm2[hash][0] = val;
  }
  hash = Hash4(val, 17);
  F0fhash[idx][2] = (F0fhash[idx][1] << 1) ^ hash;
  F0fhash[idx][1] = (F0fhash[idx][0] << 1) ^ hash;
  F0fhash[idx][0] = hash;


  F0usecnt[code]++;
  return code;
}


unsigned char F1Encode(const PCtype pc, const F1type val)
{
  register unsigned char code;
  register int hash, idx;
  register long long hicnt;

  idx = pc & 65535;
  code = 1;
  hicnt = -1;

  hash = F1fhash[idx][2];
  if ((F1usecnt[0] > hicnt) && (val == F1fcm2[hash][0])) {
    code = 0;
    hicnt = F1usecnt[0];
  }
  {
    F1fcm2[hash][0] = val;
  }
  hash = Hash4(val, 17);
  F1fhash[idx][2] = (F1fhash[idx][1] << 1) ^ hash;
  F1fhash[idx][1] = (F1fhash[idx][0] << 1) ^ hash;
  F1fhash[idx][0] = hash;


  F1usecnt[code]++;
  return code;
}


unsigned char F2Encode(const PCtype pc, const F2type val)
{
  register unsigned char code;
  register int hash, idx;
  register F2type stride;
  register long long hicnt;

  idx = pc & 65535;
  code = 1;
  hicnt = -1;
  stride = val - F2lv[idx][0];

  hash = F2dhash[idx][2];
  if ((F2usecnt[0] > hicnt) && (stride == F2dfcm2[hash][0])) {
    code = 0;
    hicnt = F2usecnt[0];
  }
  {
    F2dfcm2[hash][0] = stride;
  }
  hash = Hash8(stride, 17);
  F2dhash[idx][2] = (F2dhash[idx][1] << 1) ^ hash;
  F2dhash[idx][1] = (F2dhash[idx][0] << 1) ^ hash;
  F2dhash[idx][0] = hash;

  {
    F2lv[idx][0] = val;
  }

  F2usecnt[code]++;
  return code;
}


unsigned char F3Encode(const PCtype pc, const F3type val)
{
  register unsigned char code;
  register int hash, idx;
  register F3type stride;
  register long long hicnt;

  idx = pc & 65535;
  code = 1;
  hicnt = -1;
  stride = val - F3lv[idx][0];

  hash = F3dhash[idx][2];
  if ((F3usecnt[0] > hicnt) && (stride == F3dfcm2[hash][0])) {
    code = 0;
    hicnt = F3usecnt[0];
  }
  {
    F3dfcm2[hash][0] = stride;
  }
  hash = Hash8(stride, 17);
  F3dhash[idx][2] = (F3dhash[idx][1] << 1) ^ hash;
  F3dhash[idx][1] = (F3dhash[idx][0] << 1) ^ hash;
  F3dhash[idx][0] = hash;

  {
    F3lv[idx][0] = val;
  }

  F3usecnt[code]++;
  return code;
}


unsigned char F4Encode(const PCtype pc, const F4type val)
{
  register unsigned char code;
  register int hash, idx;
  register F4type stride;
  register long long hicnt;

  idx = pc & 65535;
  code = 1;
  hicnt = -1;
  stride = val - F4lv[idx][0];

  hash = F4dhash[idx][2];
  if ((F4usecnt[0] > hicnt) && (stride == F4dfcm2[hash][0])) {
    code = 0;
    hicnt = F4usecnt[0];
  }
  {
    F4dfcm2[hash][0] = stride;
  }
  hash = Hash8(stride, 17);
  F4dhash[idx][2] = (F4dhash[idx][1] << 1) ^ hash;
  F4dhash[idx][1] = (F4dhash[idx][0] << 1) ^ hash;
  F4dhash[idx][0] = hash;

  {
    F4lv[idx][0] = val;
  }

  F4usecnt[code]++;
  return code;
}


unsigned char F5Encode(const PCtype pc, const F5type val)
{
  register unsigned char code;
  register int hash, idx;
  register long long hicnt;

  idx = pc & 65535;
  code = 1;
  hicnt = -1;

  hash = F5fhash[idx][2];
  if ((F5usecnt[0] > hicnt) && (val == F5fcm2[hash][0])) {
    code = 0;
    hicnt = F5usecnt[0];
  }
  {
    F5fcm2[hash][0] = val;
  }
  hash = Hash4(val, 17);
  F5fhash[idx][2] = (F5fhash[idx][1] << 1) ^ hash;
  F5fhash[idx][1] = (F5fhash[idx][0] << 1) ^ hash;
  F5fhash[idx][0] = hash;


  F5usecnt[code]++;
  return code;
}


unsigned char F6Encode(const PCtype pc, const F6type val)
{
  register unsigned char code;
  register int hash, idx;
  register long long hicnt;

  idx = pc & 65535;
  code = 1;
  hicnt = -1;

  hash = F6fhash[idx][2];
  if ((F6usecnt[0] > hicnt) && (val == F6fcm2[hash][0])) {
    code = 0;
    hicnt = F6usecnt[0];
  }
  {
    F6fcm2[hash][0] = val;
  }
  hash = Hash4(val, 17);
  F6fhash[idx][2] = (F6fhash[idx][1] << 1) ^ hash;
  F6fhash[idx][1] = (F6fhash[idx][0] << 1) ^ hash;
  F6fhash[idx][0] = hash;


  F6usecnt[code]++;
  return code;
}

unsigned char F7Encode(const PCtype pc, const F7type val)
{
  register unsigned char code;
  register int hash, idx;
  register long long hicnt;
  
  idx = pc & 65535;
  code = 1;
  hicnt = -1;

  hash = F7fhash[idx][2];
  if ((F7usecnt[0] > hicnt) && (val == F7fcm2[hash][0])) {
    code = 0;
    
    hicnt = F7usecnt[0];
  }
  {
    F7fcm2[hash][0] = val;
  }
  hash = Hash4(val, 17);
  F7fhash[idx][2] = (F7fhash[idx][1] << 1) ^ hash;
  F7fhash[idx][1] = (F7fhash[idx][0] << 1) ^ hash;
  F7fhash[idx][0] = hash;

  
  F7usecnt[code]++;
  return code;
}


#ifdef __cplusplus
}
#endif
